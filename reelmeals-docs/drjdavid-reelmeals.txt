Directory structure:
└── drjdavid-reelmeals/
    ├── .cursorrules
    ├── docs/
    │   ├── PRD
    │   ├── architecture/
    │   │   ├── data-flow.md
    │   │   ├── performance.md
    │   │   ├── state-management.md
    │   │   └── system-overview.md
    │   ├── data/
    │   │   ├── migrations.md
    │   │   ├── relationships.md
    │   │   └── schema.md
    │   ├── features/
    │   │   ├── collections.md
    │   │   ├── offline-support.md
    │   │   ├── swipe-card.md
    │   │   ├── swipe-mechanics.md
    │   │   ├── user-preferences.md
    │   │   └── video-player.md
    │   ├── setup/
    │   │   ├── deployment.md
    │   │   ├── development.md
    │   │   └── firebase.md
    │   └── testing/
    │       ├── accessibility.md
    │       ├── performance.md
    │       └── strategy.md
    └── .cursor/
        └── rules/
            ├── state-management-rules.mdc
            ├── swipe-interaction-rules.mdc
            └── video-playback-rules.mdc

================================================
File: .cursorrules
================================================
# .cursorrules
project:
  name: "ReelMeals"
  description: "High-performance video discovery platform"
  tech_stack: "Next.js, Firebase, TypeScript"

global_standards:
  - "Use Firebase SDK v9 or higher for all Firebase interactions"
  - "All video components must implement error boundaries"
  - "Performance monitoring is required for all user-facing features"

performance_baselines:
  - "Time to First Frame < 2s"
  - "Target 60fps for all animations"
  - "Memory usage < 100MB on mobile devices"

================================================
File: docs/PRD
================================================
# ReelMeals: Swipeable Cooking Video Platform

## Product Requirements Document (PRD) v3.0 - Week 1 MVP

## 1. Product Vision

ReelMeals reimagines recipe discovery through an intuitive, swipe-based interface that helps home cooks find and save cooking videos they love. By combining the engaging mechanics of Tinder with the educational value of cooking content, we create an immersive learning experience that makes recipe discovery feel like a personal journey of culinary exploration.

## 2. User Experience Flow

When users open ReelMeals, they enter a focused, distraction-free environment where they can discover cooking videos one at a time. Each video plays automatically while displaying essential information like cooking time and cuisine type. Users make simple, binary decisions: swipe right to save recipes they want to try, or left to move to the next video. This creates a natural, engaging rhythm of discovery that feels both efficient and enjoyable.

## 3. Core Features - Week 1 MVP

### 3.1 Swipeable Video Interface

**User Story**: "As a home cook, I want to watch cooking videos one at a time and easily save the ones I like with a simple swipe gesture."

Technical Implementation:

```typescript
interface VideoCard {
  id: string;
  videoUrl: string;
  title: string;
  cuisine: string;
  cookingTime: number;
  difficulty: 'Easy' | 'Intermediate' | 'Advanced';
  ingredients: string[];
}

// Core video player with swipe mechanics
function VideoSwiper() {
  const [currentVideo, setCurrentVideo] = useState<VideoCard | null>(null);
  
  // Preload next video while current one plays
  useEffect(() => {
    if (currentVideo) {
      preloadNextVideo();
    }
  }, [currentVideo]);

  return (
    <SwipeableView
      onSwipeLeft={() => handleSkip()}
      onSwipeRight={() => handleSave()}
    >
      <VideoPlayer source={currentVideo?.videoUrl} />
      <RecipeOverlay recipe={currentVideo} />
    </SwipeableView>
  );
}
```

### 3.2 Recipe Collection Management

**User Story**: "As a home cook, I want to organize my saved recipes into collections so I can easily find them later."

Data Structure:

```typescript
interface Collection {
  id: string;
  userId: string;
  name: string;
  videos: VideoCard[];
  lastUpdated: Timestamp;
}

// Firestore schema ensures efficient querying
collections/{collectionId}/videos/{videoId}
```

### 3.3 Recipe Information Display

**User Story**: "As a home cook, I want to see key information about each recipe while watching, so I can make quick decisions about saving it."

Implementation:

- Overlay displays during video playback
- Shows cuisine, cooking time, and difficulty
- Smooth fade in/out animations
- Non-intrusive positioning

### 3.4 Video Playback Controls

**User Story**: "As a home cook, I want basic video controls so I can pause and rewatch parts of recipes I find interesting."

Features:

- Play/pause toggle
- Progress bar
- Mute/unmute
- Replay button
- Automatic playback for next video

### 3.5 Saved Recipe Organization

**User Story**: "As a home cook, I want to filter and sort my saved recipes by various criteria so I can find the right recipe for any occasion."

Filtering Options:

- Cuisine type
- Cooking time
- Difficulty level
- Recently saved

### 3.6 Recipe Details View

**User Story**: "As a home cook, I want to see full recipe details for my saved videos, including ingredients and steps."

Information Display:

- Complete ingredient list
- Basic instructions
- Cooking tips
- Share functionality

## 4. Technical Architecture

### Frontend (Next.js PWA)

- Progressive Web App for cross-platform access
- Framer Motion for smooth swipe animations
- React Player for video playback
- TailwindCSS for responsive design

### Backend (Firebase)

- Authentication: Firebase Auth
- Database: Firestore
- Storage: Firebase Storage
- Hosting: Firebase Hosting

Data Model:

```typescript
// Firebase Collections Structure

// Videos collection
interface Video {
  id: string;
  uploaderId: string;
  videoUrl: string;
  thumbnailUrl: string;
  title: string;
  description: string;
  cuisine: string;
  cookingTime: number;
  difficulty: string;
  ingredients: string[];
  instructions: string[];
  createdAt: Timestamp;
}

// User preferences and saved videos
interface UserData {
  id: string;
  savedVideos: string[];
  collections: {
    id: string;
    name: string;
    videos: string[];
  }[];
  preferences: {
    cuisines: string[];
    maxCookingTime?: number;
    difficulty?: string;
  };
}
```

## 5. Development Milestones

### Day 1-2: Core Video Experience

- Set up Next.js project with Firebase
- Implement video player component
- Create swipe interaction mechanics
- Build basic data fetching

### Day 3-4: Saved Recipes & Collections

- Implement save functionality
- Create collections management
- Build filtering system
- Design and implement recipe details view

### Day 5: Polish & Testing

- Add loading states
- Implement error handling
- Optimize performance
- Add offline support
- Test on multiple devices

### Day 6: Deployment & Documentation

- Deploy to Firebase Hosting
- Complete documentation
- Record demo video
- Submit deliverables

## 6. Success Metrics

### Technical Requirements

- Video start time < 2 seconds
- Smooth swipe animations (60fps)
- Offline functionality for saved recipes
- PWA installable on mobile devices

### User Experience Goals

- Clear, intuitive swipe mechanics
- Visible recipe information
- Easy collection management
- Quick save/organize workflow

### Performance Targets

- Time to Interactive < 3 seconds
- First Contentful Paint < 1.5 seconds
- Lighthouse Performance Score > 90
- PWA Score > 95

## 7. Future Enhancements (Week 2)

While out of scope for the MVP, these features are planned for Week 2:

- AI-powered recipe categorization
- Automatic difficulty assessment
- Ingredient recognition
- Personalized recommendations
- Smart recipe collections

---

*Document Version: 3.0*
*Last Updated: February 3, 2025*
*Author: Development Team*


================================================
File: docs/architecture/data-flow.md
================================================
# ReelMeals Data Flow Architecture

## Overview

This document details how data flows through the ReelMeals application, from video loading to user interactions and state management. Understanding these data flows is crucial for maintaining performance and reliability in our swipe-based video discovery platform.

## Core Data Flows

### 1. Video Discovery Flow

The video discovery process follows a specific sequence to ensure smooth playback and interaction:

```typescript
interface VideoLoadSequence {
  // Current video being watched
  current: {
    status: 'loading' | 'playing' | 'error';
    progress: number;
    buffer: number;
  };
  
  // Next video in queue
  preload: {
    status: 'pending' | 'loading' | 'ready';
    progress: number;
  };
}

class VideoSequenceManager {
  private async loadNextVideo(): Promise<void> {
    // 1. Fetch video metadata from Firestore
    // 2. Begin video preload from Storage
    // 3. Cache video data for offline access
    // 4. Prepare video player instance
  }
}
```

#### Data Flow Sequence

1. Initial Load:
   ```typescript
   async function initializeVideoFeed() {
     // 1. Fetch initial batch of video metadata
     const initialVideos = await fetchVideosBatch(BATCH_SIZE);
     
     // 2. Begin preloading first video
     await videoManager.preloadVideo(initialVideos[0]);
     
     // 3. Set up preload queue
     videoQueue.initialize(initialVideos.slice(1));
   }
   ```

2. Interaction Flow:
   ```typescript
   interface InteractionHandler {
     onSwipeRight: (video: VideoResource) => Promise<void>;
     onSwipeLeft: (video: VideoResource) => Promise<void>;
     onVideoComplete: (video: VideoResource) => Promise<void>;
   }
   ```

### 2. State Management Flow

The application state follows a unidirectional data flow pattern:

```typescript
interface StateFlow {
  // Core state types
  action: UserAction;
  reducer: StateReducer;
  effect: SideEffect;
}

// Action creators for state management
const actionCreators = {
  saveVideo: (video: VideoResource) => ({
    type: 'SAVE_VIDEO',
    payload: video,
  }),
  
  updatePreferences: (prefs: UserPreferences) => ({
    type: 'UPDATE_PREFERENCES',
    payload: prefs,
  }),
};
```

### 3. Data Persistence Flow

Data persistence follows a multi-layer caching strategy:

```typescript
interface CacheStrategy {
  // Memory cache for fastest access
  memory: {
    capacity: number;
    ttl: number;
  };
  
  // Persistent cache for offline support
  persistent: {
    maxSize: number;
    priority: 'lru' | 'fifo';
  };
}

class DataPersistenceManager {
  private async synchronizeData(): Promise<void> {
    // 1. Check for pending changes
    // 2. Upload to Firebase
    // 3. Update local cache
    // 4. Handle conflicts
  }
}
```

## Real-time Updates

### 1. Collection Synchronization

```typescript
interface SyncConfig {
  // Real-time sync settings
  strategy: 'eager' | 'lazy';
  batchSize: number;
  interval: number;
}

class CollectionSync {
  private readonly config: SyncConfig;
  
  constructor(config: SyncConfig) {
    this.config = config;
  }
  
  async synchronize(): Promise<void> {
    // Implement sync logic
  }
}
```

### 2. User Preference Updates

```typescript
interface PreferenceSync {
  local: UserPreferences;
  remote: UserPreferences;
  lastSync: Date;
}

class PreferenceManager {
  private async resolveConflicts(
    local: UserPreferences,
    remote: UserPreferences
  ): Promise<UserPreferences> {
    // Implement conflict resolution
  }
}
```

## Error Handling and Recovery

```typescript
interface ErrorHandler {
  // Error recovery strategies
  retry: {
    maxAttempts: number;
    backoffMs: number;
  };
  
  // Fallback content
  fallback: {
    type: 'cached' | 'static' | 'none';
    content: any;
  };
}

class ErrorRecovery {
  private async handleError(error: Error): Promise<void> {
    // Implement error recovery logic
  }
}
```

## Performance Optimizations

### 1. Data Prefetching

```typescript
interface PrefetchStrategy {
  // Prefetch configuration
  videos: {
    count: number;
    quality: 'high' | 'low';
  };
  
  metadata: {
    batchSize: number;
    priority: string[];
  };
}
```

### 2. Cache Management

```typescript
interface CacheManager {
  // Cache configuration
  strategy: 'lru' | 'fifo' | 'weighted';
  maxEntries: number;
  
  // Cache operations
  set(key: string, value: any): void;
  get(key: string): any;
  invalidate(pattern: string): void;
}
```

## Offline Support

### 1. Queue Management

```typescript
interface OfflineQueue {
  // Pending operations
  operations: QueuedOperation[];
  
  // Queue processing
  process(): Promise<void>;
  retry(): Promise<void>;
}

class OfflineManager {
  private queue: OfflineQueue;
  
  constructor() {
    this.queue = {
      operations: [],
      process: async () => {
        // Implement queue processing
      },
    };
  }
}
```

### 2. Storage Strategy

```typescript
interface StorageStrategy {
  // Storage quotas
  quotas: {
    video: number;
    metadata: number;
    preferences: number;
  };
  
  // Storage operations
  store(key: string, value: any): Promise<void>;
  retrieve(key: string): Promise<any>;
  clear(scope: string): Promise<void>;
}
```

## Monitoring and Logging

```typescript
interface MonitoringConfig {
  // Metrics to track
  metrics: {
    name: string;
    type: 'counter' | 'gauge' | 'histogram';
    labels: string[];
  }[];
  
  // Logging configuration
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error';
    destination: 'console' | 'firebase' | 'both';
  };
}
```

This data flow architecture ensures efficient and reliable operation of the ReelMeals application while maintaining high performance and user experience standards.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/architecture/performance.md
================================================
# ReelMeals Performance Optimization Guide

## Introduction

Performance optimization is critical for ReelMeals, as our application's success depends on providing a smooth, responsive user experience while handling video content efficiently. This guide outlines our comprehensive approach to performance optimization across all aspects of the application.

## Core Performance Principles

Our performance optimization strategy focuses on three key areas:
1. Video playback and loading optimization
2. Interaction and animation performance
3. Resource and memory management

## Video Performance Optimization

### 1. Video Loading Strategy

We implement an intelligent video loading system that balances quality with performance:

```typescript
interface LoaderConfig {
  maxPreloadCount: number;
  minimumBufferSize: number;
  maxConcurrentLoads: number;
  qualityLevels: {
    [networkType: string]: 'low' | 'medium' | 'high';
  };
}

class VideoLoadManager {
  private readonly config: LoaderConfig = {
    maxPreloadCount: 2,
    minimumBufferSize: 2000000, // 2MB
    maxConcurrentLoads: 2,
    qualityLevels: {
      '4g': 'high',
      '3g': 'medium',
      'slow-3g': 'low'
    }
  };

  constructor() {
    this.loadingQueue = new PriorityQueue();
    this.networkMonitor = new NetworkQualityMonitor();
  }

  async preloadVideo(videoId: string): Promise<void> {
    const networkQuality = await this.networkMonitor.getQuality();
    const quality = this.config.qualityLevels[networkQuality];
    
    // Begin preloading with appropriate quality level
    await this.startPreload(videoId, quality);
  }

  private async startPreload(
    videoId: string,
    quality: QualityLevel
  ): Promise<void> {
    if (this.activeLoads.size >= this.config.maxConcurrentLoads) {
      await this.queueLoad(videoId, quality);
      return;
    }

    try {
      await this.loadVideo(videoId, quality);
    } catch (error) {
      // Implement fallback strategy
      await this.handleLoadError(error, videoId);
    }
  }
}
```

### 2. Adaptive Video Quality

We implement adaptive streaming to handle varying network conditions:

```typescript
interface QualityLevel {
  resolution: string;
  bitrate: number;
  qualityScore: number;
}

class AdaptiveStreamManager {
  private qualityLevels: QualityLevel[] = [
    { resolution: '720p', bitrate: 2500000, qualityScore: 3 },
    { resolution: '480p', bitrate: 1000000, qualityScore: 2 },
    { resolution: '360p', bitrate: 500000, qualityScore: 1 }
  ];

  private networkMonitor: NetworkMonitor;
  private deviceMonitor: DeviceCapabilityMonitor;

  async selectOptimalQuality(): Promise<QualityLevel> {
    const networkSpeed = await this.networkMonitor.getMeasuredSpeed();
    const deviceCapabilities = this.deviceMonitor.getCapabilities();
    
    return this.calculateOptimalQuality(networkSpeed, deviceCapabilities);
  }

  private calculateOptimalQuality(
    speed: number,
    capabilities: DeviceCapabilities
  ): QualityLevel {
    const availableBandwidth = speed * 0.8; // Leave 20% headroom
    const deviceLimit = capabilities.maxVideoResolution;
    
    return this.qualityLevels
      .filter(quality => quality.bitrate < availableBandwidth)
      .filter(quality => this.isWithinDeviceCapability(quality, deviceLimit))
      .sort((a, b) => b.qualityScore - a.qualityScore)[0];
  }
}
```

## Interaction Performance

### 1. Gesture Optimization

We implement high-performance gesture handling for smooth swipe interactions:

```typescript
interface GestureConfig {
  swipeThreshold: number;
  velocityThreshold: number;
  directionLockThreshold: number;
  timeoutDuration: number;
}

class GestureManager {
  private readonly config: GestureConfig = {
    swipeThreshold: 50,
    velocityThreshold: 0.3,
    directionLockThreshold: 10,
    timeoutDuration: 300
  };

  constructor(element: HTMLElement) {
    this.element = element;
    this.setupGestureRecognition();
  }

  private setupGestureRecognition(): void {
    // Use passive event listeners for better scroll performance
    this.element.addEventListener('touchstart', this.handleTouchStart, {
      passive: true
    });

    this.element.addEventListener('touchmove', this.handleTouchMove, {
      passive: true
    });
  }

  private handleSwipe(direction: 'left' | 'right'): void {
    requestAnimationFrame(() => {
      this.performSwipeAnimation(direction);
    });
  }
}
```

### 2. Animation Performance

We implement hardware-accelerated animations for smooth transitions:

```typescript
interface AnimationConfig {
  useTransforms: boolean;
  frameBudget: number;
  hardwareAccelerated: boolean;
  easing: string;
}

class AnimationController {
  private readonly config: AnimationConfig = {
    useTransforms: true,
    frameBudget: 16.67, // Target 60fps
    hardwareAccelerated: true,
    easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
  };

  animate(element: HTMLElement, properties: AnimationProps): void {
    // Use transforms instead of position properties
    if (this.config.useTransforms) {
      element.style.transform = this.generateTransform(properties);
      element.style.willChange = 'transform';
    }

    // Request next frame for smooth animation
    requestAnimationFrame(() => this.updateAnimation(element));
  }

  private generateTransform(props: AnimationProps): string {
    return `translate3d(${props.x}px, ${props.y}px, 0)
            rotate(${props.rotation}deg)
            scale(${props.scale})`;
  }
}
```

## Resource Management

### 1. Memory Management

We implement aggressive memory management to prevent leaks and maintain performance:

```typescript
interface MemoryConfig {
  maxCacheSize: number;
  cleanupThreshold: number;
  monitoringInterval: number;
}

class MemoryManager {
  private readonly config: MemoryConfig = {
    maxCacheSize: 50 * 1024 * 1024, // 50MB
    cleanupThreshold: 0.8, // 80% of max
    monitoringInterval: 30000 // 30 seconds
  };

  constructor() {
    this.startMemoryMonitoring();
  }

  private startMemoryMonitoring(): void {
    setInterval(() => {
      this.checkMemoryUsage();
    }, this.config.monitoringInterval);
  }

  private async checkMemoryUsage(): Promise<void> {
    const usage = await this.getMemoryUsage();
    
    if (usage > this.config.cleanupThreshold) {
      await this.performCleanup();
    }
  }

  private async performCleanup(): Promise<void> {
    // Release unused video resources
    await this.releaseUnusedVideos();
    
    // Clear old cache entries
    await this.pruneCache();
    
    // Release unused image resources
    await this.releaseUnusedImages();
  }
}
```

### 2. Cache Strategy

We implement an intelligent caching system for optimal resource management:

```typescript
interface CacheConfig {
  maxSize: number;
  maxAge: number;
  priorityLevels: {
    [key: string]: number;
  };
}

class CacheManager {
  private readonly config: CacheConfig = {
    maxSize: 50 * 1024 * 1024, // 50MB
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    priorityLevels: {
      video: 3,
      thumbnail: 2,
      metadata: 1
    }
  };

  async cacheResource(
    key: string,
    resource: CacheableResource,
    priority: keyof typeof this.config.priorityLevels
  ): Promise<void> {
    const size = await this.calculateResourceSize(resource);
    
    if (await this.shouldEvictBeforeCaching(size)) {
      await this.evictResources(size);
    }
    
    await this.storeResource(key, resource, priority);
  }

  private async evictResources(requiredSpace: number): Promise<void> {
    const resources = await this.getSortedResources();
    let freedSpace = 0;
    
    for (const resource of resources) {
      if (freedSpace >= requiredSpace) break;
      
      await this.evictResource(resource);
      freedSpace += resource.size;
    }
  }
}
```

## Performance Monitoring

### 1. Metrics Collection

We implement comprehensive performance monitoring:

```typescript
interface PerformanceMetrics {
  ttfb: number;          // Time to First Byte
  fcp: number;          // First Contentful Paint
  lcp: number;          // Largest Contentful Paint
  fid: number;          // First Input Delay
  cls: number;          // Cumulative Layout Shift
  videoStartTime: number;
  swipeLatency: number;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    ttfb: 0,
    fcp: 0,
    lcp: 0,
    fid: 0,
    cls: 0,
    videoStartTime: 0,
    swipeLatency: 0
  };

  constructor() {
    this.setupMetricsCollection();
  }

  private setupMetricsCollection(): void {
    // Collect Web Vitals
    this.collectWebVitals();
    
    // Collect custom metrics
    this.collectCustomMetrics();
  }

  private async reportMetrics(): Promise<void> {
    // Report to analytics
    await this.analyticsService.reportMetrics(this.metrics);
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.table(this.metrics);
    }
  }
}
```

### 2. Performance Budgets

We establish and monitor performance budgets:

```typescript
interface PerformanceBudgets {
  timing: {
    ttfb: number;
    fcp: number;
    lcp: number;
  };
  size: {
    total: number;
    js: number;
    css: number;
    images: number;
  };
  metrics: {
    fps: number;
    memoryUsage: number;
  };
}

class PerformanceBudgetMonitor {
  private readonly budgets: PerformanceBudgets = {
    timing: {
      ttfb: 800,    // 800ms
      fcp: 1800,    // 1.8s
      lcp: 2500     // 2.5s
    },
    size: {
      total: 5000000,  // 5MB
      js: 500000,      // 500KB
      css: 100000,     // 100KB
      images: 2000000  // 2MB
    },
    metrics: {
      fps: 60,
      memoryUsage: 100000000  // 100MB
    }
  };

  async checkBudgets(): Promise<void> {
    const currentMetrics = await this.collectMetrics();
    const violations = this.findBudgetViolations(currentMetrics);
    
    if (violations.length > 0) {
      await this.handleBudgetViolations(violations);
    }
  }
}
```

## Performance Testing

We implement automated performance testing as part of our CI/CD pipeline:

```typescript
interface PerformanceTest {
  name: string;
  threshold: number;
  measure: () => Promise<number>;
}

class PerformanceTestRunner {
  private readonly tests: PerformanceTest[] = [
    {
      name: 'Video Load Time',
      threshold: 2000,
      measure: async () => await this.measureVideoLoad()
    },
    {
      name: 'Swipe Response Time',
      threshold: 100,
      measure: async () => await this.measureSwipeResponse()
    }
  ];

  async runTests(): Promise<TestResults> {
    const results = await Promise.all(
      this.tests.map(test => this.runTest(test))
    );
    
    return this.analyzeResults(results);
  }
}
```

This comprehensive performance optimization strategy ensures that ReelMeals provides a smooth, responsive user experience while efficiently managing system resources.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/architecture/state-management.md
================================================
# ReelMeals State Management Architecture

## Introduction

State management in ReelMeals follows a predictable, unidirectional flow pattern optimized for video playback and swipe interactions. This document outlines how we manage application state across different layers of the application, from user interactions to data persistence.

## Global State Architecture

Our application uses a combination of React Context and local component state, carefully balanced to maintain performance while ensuring data consistency. Think of this like a restaurant where different stations need to coordinate but also maintain some independence.

### Core State Structure

```typescript
// The root state interface that defines our entire application state
interface ApplicationState {
  // User-related state
  user: {
    profile: UserProfile | null;
    preferences: UserPreferences;
    collections: Collection[];
    viewHistory: VideoInteraction[];
    isAuthenticated: boolean;
  };

  // Video playback state
  player: {
    currentVideo: VideoResource | null;
    nextVideo: VideoResource | null;
    playbackStatus: 'loading' | 'playing' | 'paused' | 'error';
    progress: number;
    isMuted: boolean;
  };

  // Discovery queue state
  discovery: {
    videoQueue: VideoResource[];
    lastFetchedAt: Date;
    hasMore: boolean;
    filters: VideoFilters;
  };

  // UI state
  ui: {
    isLoading: boolean;
    activeModals: string[];
    toasts: Toast[];
    currentView: 'feed' | 'collections' | 'profile';
  };
}
```

### State Management Providers

We organize our state providers hierarchically to optimize rendering and state access:

```typescript
// Root provider that wraps our entire application
function StateProvider({ children }: PropsWithChildren) {
  return (
    <AuthProvider>
      <VideoProvider>
        <UIProvider>
          <CollectionsProvider>
            {children}
          </CollectionsProvider>
        </UIProvider>
      </VideoProvider>
    </AuthProvider>
  );
}

// Example of a specific provider implementation
function VideoProvider({ children }: PropsWithChildren) {
  // State for video playback and queue management
  const [playerState, dispatch] = useReducer(videoReducer, initialVideoState);
  
  // Memoized context value to prevent unnecessary rerenders
  const contextValue = useMemo(() => ({
    state: playerState,
    dispatch
  }), [playerState]);

  return (
    <VideoContext.Provider value={contextValue}>
      {children}
    </VideoContext.Provider>
  );
}
```

## State Updates and Actions

Our state updates follow a strict action-based pattern to maintain predictability:

```typescript
// Action type definitions for video-related state changes
type VideoAction =
  | { type: 'LOAD_VIDEO'; payload: VideoResource }
  | { type: 'UPDATE_PROGRESS'; payload: number }
  | { type: 'TOGGLE_PLAYBACK' }
  | { type: 'SAVE_VIDEO'; payload: VideoResource }
  | { type: 'SKIP_VIDEO' };

// Example reducer implementation for video state
function videoReducer(state: VideoState, action: VideoAction): VideoState {
  switch (action.type) {
    case 'LOAD_VIDEO':
      return {
        ...state,
        currentVideo: action.payload,
        playbackStatus: 'loading',
        progress: 0
      };
      
    case 'UPDATE_PROGRESS':
      return {
        ...state,
        progress: action.payload,
        // Trigger next video preload at 80% progress
        shouldPreloadNext: action.payload > 0.8
      };
      
    // Additional cases for other actions...
    
    default:
      return state;
  }
}
```

## State Persistence Strategy

We implement a sophisticated persistence strategy to maintain state across sessions:

```typescript
class StatePersistenceManager {
  // Configuration for what state to persist and how
  private config: PersistenceConfig = {
    user: {
      persist: true,
      storage: 'local',
      encryption: false
    },
    collections: {
      persist: true,
      storage: 'indexed-db',
      encryption: true
    },
    player: {
      persist: false
    }
  };

  // Persist specific state slices
  async persistState(state: Partial<ApplicationState>): Promise<void> {
    for (const [key, value] of Object.entries(state)) {
      if (this.config[key]?.persist) {
        await this.persistSlice(key, value);
      }
    }
  }

  // Restore state on application startup
  async hydrateState(): Promise<Partial<ApplicationState>> {
    const hydratedState = {};
    
    for (const [key, config] of Object.entries(this.config)) {
      if (config.persist) {
        hydratedState[key] = await this.retrieveSlice(key);
      }
    }
    
    return hydratedState;
  }
}
```

## Performance Optimizations

We implement several strategies to maintain smooth performance while managing state:

### 1. Selective Updates

```typescript
// Custom hook for accessing specific state slices
function useVideoState<K extends keyof VideoState>(
  selector: K
): VideoState[K] {
  const context = useContext(VideoContext);
  
  return useMemo(
    () => context.state[selector],
    [context.state[selector]]
  );
}

// Example usage in a component
function VideoProgress() {
  // Only re-renders when progress changes
  const progress = useVideoState('progress');
  
  return <ProgressBar value={progress} />;
}
```

### 2. State Batching

```typescript
// Batch related state updates together
function handleVideoComplete() {
  batchUpdates(() => {
    dispatch({ type: 'UPDATE_PROGRESS', payload: 1 });
    dispatch({ type: 'PREPARE_NEXT_VIDEO' });
    dispatch({ type: 'UPDATE_HISTORY' });
  });
}
```

## Error Handling

We implement comprehensive error handling in our state management:

```typescript
interface StateError {
  code: string;
  message: string;
  context: any;
  timestamp: Date;
}

class StateErrorHandler {
  private handleStateError(error: StateError): void {
    // Log error
    logger.error('State update failed', {
      code: error.code,
      context: error.context
    });

    // Attempt recovery
    this.attemptRecovery(error);

    // Notify user if necessary
    if (this.shouldNotifyUser(error)) {
      this.showUserNotification(error);
    }
  }
}
```

## Development Tools

To assist with development and debugging, we implement several developer tools:

```typescript
const STATE_DEBUGGER = {
  enabled: process.env.NODE_ENV === 'development',
  
  logStateChange(
    prevState: ApplicationState,
    nextState: ApplicationState,
    action: any
  ): void {
    if (!this.enabled) return;
    
    console.group('State Change');
    console.log('Previous State:', prevState);
    console.log('Action:', action);
    console.log('Next State:', nextState);
    console.groupEnd();
  }
};
```

This state management architecture ensures our application remains performant and maintainable while handling complex video playback and user interactions. The system is designed to be both robust for current needs and extensible for future features.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/architecture/system-overview.md
================================================
# ReelMeals System Architecture Overview

## Introduction

ReelMeals is a Progressive Web Application built on Next.js and Firebase, implementing a Tinder-style interface for cooking video discovery. This document outlines the complete system architecture, explaining how each component works together to create a seamless user experience.

## System Architecture Overview

Our architecture follows a client-server model implemented through Firebase services, with a Next.js frontend serving as a PWA. The system is designed to optimize video delivery while maintaining smooth user interactions and offline capabilities.

### Core Technical Stack

Frontend Layer:

- Next.js 14 (React 18)
- TypeScript 5.x
- TailwindCSS
- Framer Motion
- React Player

Backend Services (Firebase):

- Authentication
- Cloud Firestore
- Cloud Storage
- Hosting
- Analytics

### Component Architecture

The application follows a feature-based architecture pattern:

```
src/
├── components/          # Reusable UI components
│   ├── video/          # Video-related components
│   ├── swipe/          # Swipe interaction components
│   ├── collections/    # Collection management components
│   └── common/         # Shared UI elements
├── features/           # Feature-specific logic
│   ├── video-player/   # Video playback feature
│   ├── collections/    # Collections management
│   └── auth/           # Authentication feature
├── hooks/              # Custom React hooks
├── lib/               # Utility functions and Firebase setup
├── pages/             # Next.js pages and API routes
└── types/             # TypeScript type definitions
```

## Core Systems

### 1. Video Playback System

The video playback system is built around React Player with custom enhancements for mobile optimization:

```typescript
interface VideoPlayerConfig {
  preloadNext: boolean;
  bufferSize: number;
  quality: 'auto' | 'low' | 'medium' | 'high';
  cacheStrategy: 'memory' | 'persistent';
}

class VideoPlaybackManager {
  private currentVideo: VideoResource;
  private nextVideo: VideoResource | null;
  private bufferQueue: VideoResource[];

  constructor(config: VideoPlayerConfig) {
    this.bufferQueue = [];
    this.preloadStrategy = config.preloadNext ? 'eager' : 'lazy';
  }

  // Implementation details for video management
}
```

### 2. Swipe Interaction System

The swipe system uses Framer Motion for gesture handling with custom thresholds:

```typescript
interface SwipeConfig {
  threshold: number;
  velocity: number;
  direction: 'horizontal' | 'both';
  resistance: number;
}

interface SwipeHandlers {
  onSwipeLeft: () => void;
  onSwipeRight: () => void;
  onSwipeUp?: () => void;
  onSwipeDown?: () => void;
}
```

### 3. State Management

We use a combination of React Context and local state management:

```typescript
interface AppState {
  user: UserProfile | null;
  currentVideo: VideoResource | null;
  collections: Collection[];
  preferences: UserPreferences;
}

interface StateActions {
  type: 'SAVE_VIDEO' | 'SKIP_VIDEO' | 'UPDATE_PREFERENCES';
  payload: any;
}
```

## Data Models

### Video Resource

```typescript
interface VideoResource {
  id: string;
  url: string;
  thumbnailUrl: string;
  duration: number;
  metadata: {
    title: string;
    description: string;
    cuisine: string;
    difficulty: 'Easy' | 'Intermediate' | 'Advanced';
    cookingTime: number;
    ingredients: string[];
    instructions: string[];
  };
  engagement: {
    saves: number;
    views: number;
    completionRate: number;
  };
  technical: {
    resolution: string;
    format: string;
    size: number;
  };
}
```

### User Profile

```typescript
interface UserProfile {
  id: string;
  displayName: string;
  preferences: {
    cuisineTypes: string[];
    maxCookingTime?: number;
    difficultyLevel?: string;
  };
  collections: {
    id: string;
    name: string;
    videos: string[];
  }[];
  savedVideos: string[];
  viewHistory: {
    videoId: string;
    timestamp: Date;
    completed: boolean;
  }[];
}
```

## Performance Optimization

### Video Delivery Strategy

The system implements a sophisticated video delivery pipeline:

1. Video Preloading:
   - Preload next video while current video is playing
   - Cache video metadata for quick access
   - Implement adaptive quality based on network conditions

2. Resource Management:
   - Limit video buffer size based on device memory
   - Clear cached videos when memory pressure is high
   - Implement lazy loading for collection views

```typescript
interface CacheConfig {
  maxSize: number;
  maxAge: number;
  priorityFunction: (video: VideoResource) => number;
}

class VideoCache {
  private cache: Map<string, CachedVideo>;
  private size: number;
  private config: CacheConfig;

  constructor(config: CacheConfig) {
    this.cache = new Map();
    this.size = 0;
    this.config = config;
  }

  // Cache management implementation
}
```

## Security Model

### Authentication Flow

1. User Authentication:
   - Firebase Authentication for user management
   - JWT token-based session management
   - Secure token refresh mechanism

2. Authorization:
   - Role-based access control
   - Collection-level permissions
   - Video access restrictions

```typescript
interface SecurityConfig {
  allowedOrigins: string[];
  maxTokenAge: number;
  refreshThreshold: number;
}

class SecurityManager {
  private config: SecurityConfig;
  
  constructor(config: SecurityConfig) {
    this.config = config;
  }

  // Security implementation details
}
```

## Offline Capabilities

The PWA implements comprehensive offline support:

1. Service Worker Strategy:
   - Cache video metadata and thumbnails
   - Store user preferences and collections
   - Implement background sync for saves/skips

2. Storage Strategy:
   - IndexedDB for video metadata
   - Cache API for static assets
   - Local Storage for user preferences

```typescript
interface OfflineConfig {
  cacheName: string;
  version: number;
  maxAge: number;
  resources: {
    [key: string]: CacheStrategy;
  };
}
```

## Error Handling

The system implements a comprehensive error handling strategy:

```typescript
interface ErrorConfig {
  retryAttempts: number;
  backoffStrategy: 'linear' | 'exponential';
  fallbackContent: boolean;
}

class ErrorBoundary {
  private config: ErrorConfig;
  
  constructor(config: ErrorConfig) {
    this.config = config;
  }

  // Error handling implementation
}
```

## Monitoring and Analytics

The system implements comprehensive monitoring:

1. Performance Metrics:
   - Video load times
   - Interaction latency
   - Cache hit rates
   - Error rates

2. User Analytics:
   - Engagement metrics
   - Watch time
   - Swipe patterns
   - Collection usage

## Deployment Architecture

The application follows a multi-environment deployment strategy:

```typescript
interface DeployConfig {
  environment: 'development' | 'staging' | 'production';
  features: Feature[];
  caching: CacheStrategy;
  monitoring: MonitoringConfig;
}
```

This architecture document serves as a comprehensive guide for implementing the ReelMeals application. Each component and system is designed to work together seamlessly while maintaining high performance and reliability standards.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*


================================================
File: docs/data/migrations.md
================================================
# Database Migrations Documentation

## Overview

This document outlines our strategy for managing Firestore database migrations in ReelMeals. Given Firestore's schemaless nature, we implement a robust system to track and execute data structure changes while maintaining application stability.

## Migration System Architecture

### 1. Migration Registry

We track all migrations using a dedicated collection:

```typescript
interface Migration {
  id: string;               // Migration identifier
  version: number;          // Sequential version number
  description: string;      // What the migration does
  createdAt: Timestamp;     // When migration was created
  executedAt?: Timestamp;   // When migration was run
  status: 'pending' | 'running' | 'completed' | 'failed';
  error?: string;          // Error details if failed
  stats?: {
    documentsProcessed: number;
    documentsUpdated: number;
    errors: number;
  };
}

class MigrationRegistry {
  private readonly db: Firestore;
  private readonly collection = 'migrations';

  async registerMigration(migration: Omit<Migration, 'id'>): Promise<string> {
    const ref = this.db.collection(this.collection).doc();
    await ref.set({
      ...migration,
      id: ref.id,
      status: 'pending',
      createdAt: Timestamp.now()
    });
    return ref.id;
  }

  async updateMigrationStatus(
    id: string,
    status: Migration['status'],
    stats?: Migration['stats']
  ): Promise<void> {
    await this.db.collection(this.collection).doc(id).update({
      status,
      executedAt: Timestamp.now(),
      ...(stats && { stats })
    });
  }
}
```

### 2. Migration Manager

Handles the execution and tracking of migrations:

```typescript
class MigrationManager {
  private readonly registry: MigrationRegistry;
  private readonly batchSize = 500;
  private readonly parallelBatches = 3;

  constructor(registry: MigrationRegistry) {
    this.registry = registry;
  }

  async executeMigration(
    migrationId: string,
    migrationFn: (batch: WriteBatch) => Promise<void>
  ): Promise<void> {
    try {
      await this.registry.updateMigrationStatus(migrationId, 'running');

      const stats = {
        documentsProcessed: 0,
        documentsUpdated: 0,
        errors: 0
      };

      // Execute migration in batches
      await this.executeBatchedMigration(migrationFn, stats);

      await this.registry.updateMigrationStatus(
        migrationId,
        'completed',
        stats
      );
    } catch (error) {
      await this.registry.updateMigrationStatus(
        migrationId,
        'failed',
        { error: error.message }
      );
      throw error;
    }
  }

  private async executeBatchedMigration(
    migrationFn: (batch: WriteBatch) => Promise<void>,
    stats: Migration['stats']
  ): Promise<void> {
    // Implementation of batched execution
  }
}
```

## Migration Patterns

### 1. Schema Version Tracking

We track schema versions at both collection and document levels:

```typescript
interface SchemaVersion {
  collection: string;
  version: number;
  updatedAt: Timestamp;
}

interface VersionedDocument {
  _meta: {
    version: number;
    lastMigration: string;
    migratedAt: Timestamp;
  };
  // ... rest of document data
}

class SchemaVersionManager {
  private readonly versionsCollection = 'schemaVersions';

  async updateSchemaVersion(
    collection: string,
    version: number
  ): Promise<void> {
    await this.db
      .collection(this.versionsCollection)
      .doc(collection)
      .set({
        version,
        updatedAt: Timestamp.now()
      });
  }

  async getSchemaVersion(collection: string): Promise<number> {
    const doc = await this.db
      .collection(this.versionsCollection)
      .doc(collection)
      .get();
    return doc.exists ? doc.data()?.version : 0;
  }
}
```

### 2. Progressive Migrations

We implement migrations that can run progressively on large datasets:

```typescript
class ProgressiveMigration {
  private readonly checkpointCollection = 'migrationCheckpoints';

  async executeLargeMigration(
    migrationId: string,
    query: Query,
    transformFn: (doc: DocumentData) => DocumentData
  ): Promise<void> {
    let lastDocumentId = await this.getCheckpoint(migrationId);
    let hasMore = true;

    while (hasMore) {
      const batch = this.db.batch();
      let batchCount = 0;

      // Query next batch
      let batchQuery = query.orderBy('__name__').limit(this.batchSize);
      if (lastDocumentId) {
        const lastDoc = await this.db.doc(lastDocumentId).get();
        batchQuery = batchQuery.startAfter(lastDoc);
      }

      const snapshot = await batchQuery.get();

      // Process documents
      snapshot.forEach(doc => {
        const transformed = transformFn(doc.data());
        batch.update(doc.ref, transformed);
        lastDocumentId = doc.ref.path;
        batchCount++;
      });

      if (batchCount > 0) {
        await batch.commit();
        await this.saveCheckpoint(migrationId, lastDocumentId);
      }

      hasMore = batchCount === this.batchSize;
    }
  }

  private async getCheckpoint(
    migrationId: string
  ): Promise<string | null> {
    const doc = await this.db
      .collection(this.checkpointCollection)
      .doc(migrationId)
      .get();
    return doc.exists ? doc.data()?.lastDocumentId : null;
  }

  private async saveCheckpoint(
    migrationId: string,
    lastDocumentId: string
  ): Promise<void> {
    await this.db
      .collection(this.checkpointCollection)
      .doc(migrationId)
      .set({
        lastDocumentId,
        updatedAt: Timestamp.now()
      });
  }
}
```

### 3. Fallback Mechanisms

We implement fallback handling for partial migrations:

```typescript
class MigrationFallbackHandler {
  async handleMigrationFailure(
    migrationId: string,
    error: Error
  ): Promise<void> {
    // Log failure
    await this.logMigrationFailure(migrationId, error);

    // Attempt rollback if possible
    await this.attemptRollback(migrationId);

    // Update application state
    await this.updateApplicationState(migrationId);
  }

  private async attemptRollback(migrationId: string): Promise<void> {
    // Implementation of rollback logic
  }
}
```

## Migration Examples

### 1. Adding New Fields

```typescript
const addCookingTimeMigration = async () => {
  const migration: Migration = {
    version: 1,
    description: 'Add cookingTime field to recipes',
    status: 'pending',
    createdAt: Timestamp.now()
  };

  const migrationId = await registry.registerMigration(migration);

  await migrationManager.executeMigration(migrationId, async (batch) => {
    const recipes = await db.collection('recipes')
      .where('_meta.version', '<', 1)
      .limit(batchSize)
      .get();

    recipes.forEach(doc => {
      const data = doc.data();
      batch.update(doc.ref, {
        cookingTime: calculateCookingTime(data),
        '_meta.version': 1,
        '_meta.lastMigration': migrationId,
        '_meta.migratedAt': Timestamp.now()
      });
    });
  });
};
```

### 2. Restructuring Data

```typescript
const restructureUserPreferencesMigration = async () => {
  const migration: Migration = {
    version: 2,
    description: 'Restructure user preferences',
    status: 'pending',
    createdAt: Timestamp.now()
  };

  const migrationId = await registry.registerMigration(migration);

  await migrationManager.executeMigration(migrationId, async (batch) => {
    const users = await db.collection('users')
      .where('_meta.version', '<', 2)
      .limit(batchSize)
      .get();

    users.forEach(doc => {
      const data = doc.data();
      const newPreferences = restructurePreferences(data.preferences);
      
      batch.update(doc.ref, {
        preferences: newPreferences,
        '_meta.version': 2,
        '_meta.lastMigration': migrationId,
        '_meta.migratedAt': Timestamp.now()
      });
    });
  });
};
```

## Testing Migrations

We implement comprehensive testing for migrations:

```typescript
class MigrationTester {
  async testMigration(
    migrationFn: () => Promise<void>,
    testData: any[]
  ): Promise<TestResult> {
    // Set up test environment
    const testDb = await this.createTestDatabase();
    await this.seedTestData(testDb, testData);

    // Execute migration
    await migrationFn();

    // Verify results
    return await this.verifyMigrationResults(testDb);
  }

  private async verifyMigrationResults(
    testDb: Firestore
  ): Promise<TestResult> {
    // Implementation of verification logic
  }
}
```

This documentation outlines our comprehensive approach to managing Firestore migrations while maintaining data integrity and application stability.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/data/relationships.md
================================================
# Database Relationships Documentation

## Overview

This document outlines the relationship patterns used in ReelMeals' Firestore database. Given Firestore's NoSQL nature, we implement relationships differently than in traditional SQL databases, optimizing for query performance and scalability.

## Core Relationship Patterns

### 1. One-to-One Relationships

We handle one-to-one relationships through direct document references or nested objects:

```typescript
// Example: User Profile relationship
interface User {
  id: string;
  email: string;
  // One-to-one nested relationship
  profile: {
    displayName: string;
    photoUrl: string;
    bio: string;
    joinDate: Timestamp;
  };
}

// Access pattern
const getUserProfile = async (userId: string) => {
  const userDoc = await db.collection('users').doc(userId).get();
  return userDoc.data()?.profile;
};
```

### 2. One-to-Few Relationships

For relationships where the "many" side is limited and unlikely to grow significantly:

```typescript
// Example: User Preferences relationship
interface User {
  id: string;
  // One-to-few nested relationship
  preferences: {
    cuisinePreferences: string[];
    dietaryRestrictions: string[];
    skillLevel: string;
    notificationSettings: {
      email: boolean;
      push: boolean;
      frequency: 'daily' | 'weekly' | 'never';
    };
  };
}

// Access pattern
const updateUserPreferences = async (
  userId: string, 
  updates: Partial<UserPreferences>
) => {
  await db.collection('users').doc(userId).update({
    'preferences': { ...updates }
  });
};
```

### 3. One-to-Many Relationships

For one-to-many relationships, we use separate collections with references:

```typescript
// Example: User to Collections relationship
interface Collection {
  id: string;
  userId: string;  // Reference to parent user
  name: string;
  // Other collection fields
}

// Access patterns
const getUserCollections = async (userId: string) => {
  const collections = await db
    .collection('collections')
    .where('userId', '==', userId)
    .get();
  return collections.docs.map(doc => doc.data());
};

// For pagination
const getPagedUserCollections = async (
  userId: string,
  lastDoc?: QueryDocumentSnapshot,
  limit: number = 10
) => {
  let query = db
    .collection('collections')
    .where('userId', '==', userId)
    .orderBy('createdAt', 'desc')
    .limit(limit);

  if (lastDoc) {
    query = query.startAfter(lastDoc);
  }

  return await query.get();
};
```

### 4. Many-to-Many Relationships

We implement many-to-many relationships using junction collections:

```typescript
// Example: Users saving Videos relationship
interface SavedVideo {
  id: string;
  userId: string;
  videoId: string;
  savedAt: Timestamp;
  notes?: string;
  collectionIds: string[];  // Optional organization
}

// Access patterns
const saveVideo = async (
  userId: string,
  videoId: string,
  collectionId?: string
) => {
  const savedVideoRef = db.collection('savedVideos').doc();
  await savedVideoRef.set({
    userId,
    videoId,
    savedAt: Timestamp.now(),
    collectionIds: collectionId ? [collectionId] : []
  });
};

const getUserSavedVideos = async (
  userId: string,
  collectionId?: string
) => {
  let query = db
    .collection('savedVideos')
    .where('userId', '==', userId);

  if (collectionId) {
    query = query.where('collectionIds', 'array-contains', collectionId);
  }

  return await query.get();
};
```

## Relationship Querying Strategies

### 1. Denormalization for Performance

We strategically denormalize data to optimize read performance:

```typescript
// Example: Denormalized video data in collections
interface CollectionVideo {
  id: string;
  videoId: string;
  // Denormalized video data for quick access
  title: string;
  thumbnailUrl: string;
  duration: number;
  addedAt: Timestamp;
}

// Update denormalized data
const updateVideoMetadata = async (
  videoId: string,
  updates: Partial<VideoMetadata>
) => {
  // Update main video document
  await db.collection('videos').doc(videoId).update(updates);

  // Update denormalized data in collections
  const batch = db.batch();
  const collectionRefs = await db
    .collectionGroup('videos')
    .where('videoId', '==', videoId)
    .get();

  collectionRefs.forEach(doc => {
    batch.update(doc.ref, updates);
  });

  await batch.commit();
};
```

### 2. Fan-out Pattern for Popular Data

For frequently accessed relationships, we implement fan-out writes:

```typescript
// Example: Updating video metadata across all references
const fanOutVideoUpdate = async (
  videoId: string,
  updates: Partial<VideoMetadata>
) => {
  const batch = db.batch();
  
  // Update main video document
  batch.update(db.collection('videos').doc(videoId), updates);

  // Update in popular collections
  const popularCollections = await db
    .collection('collections')
    .where('videoCount', '>', 1000)
    .where('videos', 'array-contains', videoId)
    .get();

  popularCollections.forEach(collection => {
    batch.update(collection.ref, {
      [`videos.${videoId}`]: updates
    });
  });

  await batch.commit();
};
```

## Query Optimization

### 1. Composite Indexes

We maintain composite indexes for common relationship queries:

```typescript
// Example composite index configuration
{
  "indexes": [
    {
      "collectionGroup": "savedVideos",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "savedAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "collections",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "videoCount", "order": "DESCENDING" }
      ]
    }
  ]
}
```

### 2. Query Helpers

We implement helper functions to manage complex relationship queries:

```typescript
class RelationshipQueryHelper {
  // Get all videos in a user's collections
  async getUserCollectionVideos(
    userId: string,
    options: QueryOptions = {}
  ): Promise<Video[]> {
    const { limit = 20, lastDoc, filter } = options;

    let query = db
      .collection('collections')
      .where('userId', '==', userId);

    if (filter) {
      query = this.applyFilter(query, filter);
    }

    const collections = await query.get();
    const videoIds = new Set<string>();

    collections.forEach(doc => {
      const data = doc.data();
      data.videos.forEach((video: any) => {
        videoIds.add(video.videoId);
      });
    });

    return await this.fetchVideos(Array.from(videoIds), limit, lastDoc);
  }

  private applyFilter(query: Query, filter: QueryFilter): Query {
    // Apply filter logic
    return query;
  }

  private async fetchVideos(
    ids: string[],
    limit: number,
    lastDoc?: QueryDocumentSnapshot
  ): Promise<Video[]> {
    // Fetch video documents
    return [];
  }
}
```

## Data Consistency

### 1. Transaction Handling

We use transactions to maintain relationship consistency:

```typescript
const addVideoToCollection = async (
  collectionId: string,
  videoId: string
) => {
  await db.runTransaction(async (transaction) => {
    // Read current collection and video
    const collectionRef = db.collection('collections').doc(collectionId);
    const videoRef = db.collection('videos').doc(videoId);
    
    const [collectionDoc, videoDoc] = await Promise.all([
      transaction.get(collectionRef),
      transaction.get(videoRef)
    ]);

    if (!collectionDoc.exists || !videoDoc.exists) {
      throw new Error('Document not found');
    }

    // Update collection
    transaction.update(collectionRef, {
      videoCount: increment(1),
      videos: arrayUnion({
        videoId,
        addedAt: Timestamp.now(),
        title: videoDoc.data()?.title,
        thumbnailUrl: videoDoc.data()?.thumbnailUrl
      })
    });

    // Update video's collection count
    transaction.update(videoRef, {
      collectionCount: increment(1)
    });
  });
};
```

### 2. Batch Updates

We use batched writes for relationship modifications:

```typescript
const removeVideoFromCollections = async (
  videoId: string,
  collectionIds: string[]
) => {
  const batch = db.batch();

  // Update each collection
  collectionIds.forEach(collectionId => {
    const collectionRef = db
      .collection('collections')
      .doc(collectionId);

    batch.update(collectionRef, {
      videoCount: increment(-1),
      videos: arrayRemove(videoId)
    });
  });

  // Update video document
  const videoRef = db.collection('videos').doc(videoId);
  batch.update(videoRef, {
    collectionCount: increment(-collectionIds.length)
  });

  await batch.commit();
};
```

This documentation outlines our approach to managing relationships in Firestore while maintaining performance and data consistency.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/data/schema.md
================================================
# Database Schema Documentation

## Overview

ReelMeals uses Firebase Firestore as its primary database, with Cloud Storage for media assets. This document outlines our database schema, collection structures, and indexing strategies.

## Collection Schemas

### Users Collection

```typescript
interface User {
  id: string;                    // Firestore Document ID
  uid: string;                   // Firebase Auth UID
  email: string;                 // User's email
  displayName: string;           // Display name
  photoURL?: string;            // Profile photo URL
  createdAt: Timestamp;         // Account creation date
  lastLogin: Timestamp;         // Last login timestamp
  preferences: {
    cuisineTypes: string[];     // Preferred cuisine types
    dietaryRestrictions: string[];
    skillLevel: 'beginner' | 'intermediate' | 'advanced';
    maxCookingTime?: number;    // Maximum cooking time in minutes
  };
  stats: {
    totalSaved: number;         // Total saved recipes
    completedRecipes: number;   // Recipes marked as cooked
    avgRating: number;          // Average rating given
  };
  settings: {
    notifications: boolean;     // Notification preferences
    language: string;          // Preferred language
    theme: 'light' | 'dark' | 'system';
  };
}

// Indexing strategy
// Single-field indexes:
// - email (ASC)
// - createdAt (DESC)
// - lastLogin (DESC)
// Composite indexes:
// - [cuisineTypes, skillLevel]
// - [lastLogin, totalSaved]
```

### Videos Collection

```typescript
interface Video {
  id: string;                   // Firestore Document ID
  title: string;                // Recipe title
  description: string;          // Recipe description
  uploaderId: string;           // Reference to users collection
  createdAt: Timestamp;         // Upload timestamp
  duration: number;             // Video duration in seconds
  metadata: {
    cuisine: string;            // Cuisine type
    difficulty: 'easy' | 'medium' | 'hard';
    prepTime: number;           // Preparation time in minutes
    cookingTime: number;        // Cooking time in minutes
    servings: number;           // Number of servings
    calories: number;           // Calories per serving
  };
  ingredients: {
    name: string;              // Ingredient name
    amount: number;            // Amount
    unit: string;              // Measurement unit
    notes?: string;            // Optional notes
  }[];
  steps: {
    order: number;             // Step order
    description: string;       // Step description
    timestamp: number;         // Video timestamp for step
    duration: number;          // Duration of step in seconds
  }[];
  assets: {
    videoUrl: string;          // Cloud Storage URL
    thumbnailUrl: string;      // Thumbnail image URL
    previewGif?: string;       // Preview GIF URL
  };
  engagement: {
    views: number;             // View count
    saves: number;             // Save count
    completions: number;       // Recipe completion count
    rating: number;            // Average rating
  };
  status: 'processing' | 'active' | 'disabled';
}

// Indexing strategy
// Single-field indexes:
// - createdAt (DESC)
// - cuisine (ASC)
// - difficulty (ASC)
// - views (DESC)
// Composite indexes:
// - [cuisine, difficulty, views]
// - [createdAt, engagement.rating]
```

### Collections Collection

```typescript
interface Collection {
  id: string;                   // Firestore Document ID
  userId: string;               // Reference to users collection
  name: string;                 // Collection name
  description?: string;         // Optional description
  createdAt: Timestamp;         // Creation timestamp
  updatedAt: Timestamp;         // Last update timestamp
  videos: {
    videoId: string;           // Reference to videos collection
    addedAt: Timestamp;        // When video was added
    notes?: string;            // Optional user notes
    order: number;             // Display order
  }[];
  isDefault: boolean;          // Whether this is a default collection
  privacy: 'private' | 'public' | 'shared';
  shareableLink?: string;      // Shareable link if public/shared
  collaborators?: string[];    // User IDs of collaborators
}

// Indexing strategy
// Single-field indexes:
// - userId (ASC)
// - createdAt (DESC)
// - updatedAt (DESC)
// Composite indexes:
// - [userId, updatedAt]
// - [privacy, createdAt]
```

### Interactions Collection

```typescript
interface Interaction {
  id: string;                   // Firestore Document ID
  userId: string;               // Reference to users collection
  videoId: string;              // Reference to videos collection
  type: 'view' | 'save' | 'complete' | 'rate';
  timestamp: Timestamp;         // Interaction timestamp
  data?: {
    rating?: number;           // Rating value if type is 'rate'
    watchDuration?: number;    // Watch duration if type is 'view'
    completionStatus?: 'success' | 'abandoned';
  };
  deviceInfo: {
    platform: string;          // Device platform
    os: string;                // Operating system
    browser: string;           // Browser information
  };
}

// Indexing strategy
// Single-field indexes:
// - userId (ASC)
// - videoId (ASC)
// - timestamp (DESC)
// Composite indexes:
// - [userId, type, timestamp]
// - [videoId, type, timestamp]
```

## Subcollections

### Comments Subcollection (on Videos)

```typescript
interface Comment {
  id: string;                   // Firestore Document ID
  userId: string;               // Reference to users collection
  content: string;              // Comment content
  createdAt: Timestamp;         // Creation timestamp
  editedAt?: Timestamp;         // Last edit timestamp
  likes: number;                // Like count
  replies: {
    userId: string;            // User who replied
    content: string;           // Reply content
    createdAt: Timestamp;      // Reply timestamp
  }[];
  timestamp?: number;          // Video timestamp if timestamp-specific
}

// Indexing strategy
// Single-field indexes:
// - createdAt (DESC)
// - likes (DESC)
```

## Security Rules

```typescript
// Firestore security rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // User document rules
    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth.uid == userId;
    }

    // Video document rules
    match /videos/{videoId} {
      allow read: if true;  // Public read access
      allow write: if request.auth != null 
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'creator';
    }

    // Collection document rules
    match /collections/{collectionId} {
      allow read: if request.auth != null 
        && (resource.data.userId == request.auth.uid 
            || resource.data.privacy == 'public'
            || request.auth.uid in resource.data.collaborators);
      allow write: if request.auth != null 
        && (resource.data.userId == request.auth.uid 
            || request.auth.uid in resource.data.collaborators);
    }
  }
}
```

## Data Validation

We implement comprehensive data validation using TypeScript and Firebase Functions:

```typescript
// Server-side validation functions
export function validateVideo(video: Video): ValidationResult {
  const errors: ValidationError[] = [];

  // Title validation
  if (!video.title || video.title.length < 3) {
    errors.push({
      field: 'title',
      message: 'Title must be at least 3 characters long'
    });
  }

  // Duration validation
  if (video.duration <= 0) {
    errors.push({
      field: 'duration',
      message: 'Duration must be greater than 0'
    });
  }

  // Metadata validation
  if (!VALID_CUISINES.includes(video.metadata.cuisine)) {
    errors.push({
      field: 'metadata.cuisine',
      message: 'Invalid cuisine type'
    });
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}
```

## Migration Strategies

For schema updates and data migrations, we follow these patterns:

```typescript
interface MigrationJob {
  id: string;
  version: number;
  description: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime?: Timestamp;
  endTime?: Timestamp;
  progress: number;
  error?: string;
}

class DataMigrator {
  async migrate(version: number): Promise<void> {
    const job = await this.createMigrationJob(version);
    
    try {
      await this.executeMigration(job);
      await this.updateMigrationStatus(job.id, 'completed');
    } catch (error) {
      await this.handleMigrationError(job.id, error);
      throw error;
    }
  }

  private async executeMigration(job: MigrationJob): Promise<void> {
    // Implementation specific to migration version
  }
}
```

This schema documentation provides a comprehensive overview of our database structure, ensuring consistency and maintainability across the application.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/collections.md
================================================
# Collections Management System Documentation

## Overview

The Collections Management System enables users to organize their saved cooking videos into meaningful groups. Similar to how a chef organizes their recipe cards into categories, our system allows users to create, manage, and organize their saved videos into collections that make sense for their cooking journey.

## Core Architecture

### Data Model

```typescript
interface Collection {
  id: string;
  userId: string;
  name: string;
  description?: string;
  thumbnail?: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
  videoCount: number;
  isDefault: boolean;
  sortOrder: number;
  videos: CollectionVideo[];
}

interface CollectionVideo {
  id: string;
  videoId: string;
  addedAt: Timestamp;
  sortOrder: number;
  notes?: string;
  customTags?: string[];
}

interface CollectionMeta {
  totalVideos: number;
  lastWatched: Timestamp;
  cuisineTypes: string[];
  averageDuration: number;
  difficultyBreakdown: {
    easy: number;
    intermediate: number;
    advanced: number;
  };
}
```

### Collection Manager

The CollectionManager handles all collection-related operations:

```typescript
class CollectionManager {
  private readonly firestore: Firestore;
  private readonly userId: string;
  private readonly cache: CollectionCache;

  constructor(firestore: Firestore, userId: string) {
    this.firestore = firestore;
    this.userId = userId;
    this.cache = new CollectionCache();
  }

  async createCollection(data: Partial<Collection>): Promise<string> {
    const collection: Collection = {
      id: uuid(),
      userId: this.userId,
      name: data.name || 'New Collection',
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
      videoCount: 0,
      isDefault: false,
      sortOrder: await this.getNextSortOrder(),
      videos: [],
      ...data
    };

    await this.firestore
      .collection('collections')
      .doc(collection.id)
      .set(collection);

    this.cache.set(collection.id, collection);
    return collection.id;
  }

  async addVideoToCollection(
    collectionId: string,
    videoId: string,
    options?: {
      notes?: string;
      tags?: string[];
    }
  ): Promise<void> {
    const collection = await this.getCollection(collectionId);
    
    if (!collection) {
      throw new Error('Collection not found');
    }

    const collectionVideo: CollectionVideo = {
      id: uuid(),
      videoId,
      addedAt: Timestamp.now(),
      sortOrder: collection.videos.length,
      notes: options?.notes,
      customTags: options?.tags
    };

    await this.firestore
      .collection('collections')
      .doc(collectionId)
      .update({
        videos: arrayUnion(collectionVideo),
        videoCount: increment(1),
        updatedAt: Timestamp.now()
      });

    this.cache.invalidate(collectionId);
  }

  async removeVideoFromCollection(
    collectionId: string,
    videoId: string
  ): Promise<void> {
    const collection = await this.getCollection(collectionId);
    
    if (!collection) {
      throw new Error('Collection not found');
    }

    const updatedVideos = collection.videos.filter(v => v.videoId !== videoId);

    await this.firestore
      .collection('collections')
      .doc(collectionId)
      .update({
        videos: updatedVideos,
        videoCount: increment(-1),
        updatedAt: Timestamp.now()
      });

    this.cache.invalidate(collectionId);
  }

  async getCollectionMetadata(collectionId: string): Promise<CollectionMeta> {
    const collection = await this.getCollection(collectionId);
    
    if (!collection) {
      throw new Error('Collection not found');
    }

    const videos = await this.fetchCollectionVideos(collection.videos);
    
    return {
      totalVideos: videos.length,
      lastWatched: this.calculateLastWatched(videos),
      cuisineTypes: this.extractUniqueCuisines(videos),
      averageDuration: this.calculateAverageDuration(videos),
      difficultyBreakdown: this.calculateDifficultyBreakdown(videos)
    };
  }

  private async getNextSortOrder(): Promise<number> {
    const collections = await this.firestore
      .collection('collections')
      .where('userId', '==', this.userId)
      .orderBy('sortOrder', 'desc')
      .limit(1)
      .get();

    if (collections.empty) {
      return 0;
    }

    return collections.docs[0].data().sortOrder + 1;
  }
}
```

### Collection Cache

We implement an intelligent caching system to improve performance:

```typescript
class CollectionCache {
  private cache: Map<string, CacheEntry<Collection>> = new Map();
  private readonly maxAge = 5 * 60 * 1000; // 5 minutes

  set(id: string, collection: Collection): void {
    this.cache.set(id, {
      data: collection,
      timestamp: Date.now()
    });
  }

  get(id: string): Collection | null {
    const entry = this.cache.get(id);
    
    if (!entry) {
      return null;
    }

    if (Date.now() - entry.timestamp > this.maxAge) {
      this.cache.delete(id);
      return null;
    }

    return entry.data;
  }

  invalidate(id: string): void {
    this.cache.delete(id);
  }

  clear(): void {
    this.cache.clear();
  }
}
```

## User Interface Components

### Collection List Component

```typescript
interface CollectionListProps {
  collections: Collection[];
  onCollectionSelect: (id: string) => void;
  onCreateCollection: () => void;
}

const CollectionList: React.FC<CollectionListProps> = ({
  collections,
  onCollectionSelect,
  onCreateCollection
}) => {
  return (
    <div className="collection-list">
      {/* Create new collection button */}
      <button
        className="create-collection-btn"
        onClick={onCreateCollection}
      >
        <PlusIcon className="w-6 h-6" />
        <span>New Collection</span>
      </button>

      {/* Collection grid */}
      <div className="collection-grid">
        {collections.map(collection => (
          <CollectionCard
            key={collection.id}
            collection={collection}
            onClick={() => onCollectionSelect(collection.id)}
          />
        ))}
      </div>
    </div>
  );
};
```

### Collection Detail View

```typescript
interface CollectionDetailProps {
  collectionId: string;
}

const CollectionDetail: React.FC<CollectionDetailProps> = ({
  collectionId
}) => {
  const [collection, setCollection] = useState<Collection | null>(null);
  const [metadata, setMetadata] = useState<CollectionMeta | null>(null);

  useEffect(() => {
    loadCollectionData();
  }, [collectionId]);

  return (
    <div className="collection-detail">
      {/* Collection header */}
      <CollectionHeader
        collection={collection}
        metadata={metadata}
      />

      {/* Video grid */}
      <CollectionVideoGrid
        videos={collection?.videos || []}
        onVideoSelect={handleVideoSelect}
        onVideoRemove={handleVideoRemove}
      />

      {/* Collection settings */}
      <CollectionSettings
        collection={collection}
        onUpdate={handleCollectionUpdate}
      />
    </div>
  );
};
```

## Offline Support

We implement robust offline support for collections:

```typescript
class OfflineCollectionManager {
  private readonly db: IDBDatabase;
  private readonly syncQueue: SyncQueue;

  constructor() {
    this.initializeDatabase();
    this.syncQueue = new SyncQueue();
  }

  async saveOfflineChanges(
    action: 'create' | 'update' | 'delete',
    data: any
  ): Promise<void> {
    // Save change to IndexedDB
    await this.saveToLocal(action, data);

    // Add to sync queue
    this.syncQueue.add({
      action,
      data,
      timestamp: Date.now()
    });
  }

  async synchronize(): Promise<void> {
    const changes = await this.syncQueue.getAll();
    
    for (const change of changes) {
      try {
        await this.pushChangeToServer(change);
        await this.syncQueue.remove(change.id);
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}
```

## Performance Considerations

1. **Eager Loading**: We preload collection metadata for faster navigation
2. **Lazy Loading**: Videos within collections are loaded on-demand
3. **Caching**: Frequently accessed collections are cached in memory
4. **Batch Updates**: Collection changes are batched for efficiency
5. **IndexedDB**: Offline support with efficient local storage

## Error Handling

```typescript
class CollectionErrorHandler {
  handle(error: Error): void {
    switch (error.name) {
      case 'QuotaExceededError':
        this.handleStorageQuotaError();
        break;
      case 'NetworkError':
        this.handleNetworkError();
        break;
      case 'PermissionError':
        this.handlePermissionError();
        break;
      default:
        this.handleUnknownError(error);
    }
  }

  private handleStorageQuotaError(): void {
    // Implement storage quota error handling
  }

  private handleNetworkError(): void {
    // Implement network error handling
  }

  private handlePermissionError(): void {
    // Implement permission error handling
  }

  private handleUnknownError(error: Error): void {
    // Implement unknown error handling
  }
}
```

This documentation provides a comprehensive overview of our Collections Management System, focusing on the key components that enable users to organize and manage their saved cooking videos effectively.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/offline-support.md
================================================
# Offline Support System Documentation

## Overview

ReelMeals implements comprehensive offline support to ensure users can access their saved recipes and collections without an internet connection. This document details our offline-first architecture, which uses Service Workers, IndexedDB, and a sophisticated sync system to provide a seamless experience regardless of network status.

## Core Architecture

### 1. Service Worker Implementation

Our Service Worker manages caching and offline access:

```typescript
interface CacheConfig {
  version: string;
  caches: {
    static: string[];    // Static assets like images and JS
    dynamic: string[];   // Dynamic content like video thumbnails
    api: string[];       // API responses
  };
  maxAge: {
    static: number;      // Cache duration for static assets
    dynamic: number;     // Cache duration for dynamic content
    api: number;         // Cache duration for API responses
  };
}

class ServiceWorkerManager {
  private readonly config: CacheConfig = {
    version: '1.0.0',
    caches: {
      static: ['/styles', '/scripts', '/images'],
      dynamic: ['/thumbnails', '/previews'],
      api: ['/api/recipes', '/api/collections']
    },
    maxAge: {
      static: 7 * 24 * 60 * 60 * 1000,  // 1 week
      dynamic: 24 * 60 * 60 * 1000,     // 1 day
      api: 60 * 60 * 1000               // 1 hour
    }
  };

  async initialize(): Promise<void> {
    if ('serviceWorker' in navigator) {
      try {
        const registration = await navigator.serviceWorker.register(
          '/service-worker.js',
          { scope: '/' }
        );
        
        console.log('ServiceWorker registered:', registration);
        
        await this.setupCaches();
        await this.precacheStaticAssets();
      } catch (error) {
        console.error('ServiceWorker registration failed:', error);
      }
    }
  }

  private async setupCaches(): Promise<void> {
    const cacheNames = await caches.keys();
    
    // Clean up old caches
    await Promise.all(
      cacheNames
        .filter(name => !Object.values(this.config.caches).includes(name))
        .map(name => caches.delete(name))
    );
  }

  private async precacheStaticAssets(): Promise<void> {
    const cache = await caches.open(this.config.caches.static);
    await cache.addAll(this.config.static);
  }
}
```

### 2. Data Persistence Layer

We use IndexedDB for offline data storage:

```typescript
interface StorageSchema {
  recipes: {
    id: string;
    data: VideoResource;
    timestamp: number;
  };
  collections: {
    id: string;
    data: Collection;
    timestamp: number;
  };
  syncQueue: {
    id: string;
    action: 'create' | 'update' | 'delete';
    entity: 'recipe' | 'collection';
    data: any;
    timestamp: number;
  };
}

class OfflineStorage {
  private db: IDBDatabase | null = null;
  private readonly dbName = 'ReelMealsOffline';
  private readonly version = 1;

  async initialize(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object stores
        db.createObjectStore('recipes', { keyPath: 'id' });
        db.createObjectStore('collections', { keyPath: 'id' });
        db.createObjectStore('syncQueue', { keyPath: 'id' });
      };
    });
  }

  async saveRecipe(recipe: VideoResource): Promise<void> {
    await this.save('recipes', {
      id: recipe.id,
      data: recipe,
      timestamp: Date.now()
    });
  }

  async getRecipe(id: string): Promise<VideoResource | null> {
    const record = await this.get('recipes', id);
    return record?.data || null;
  }

  private async save(
    storeName: keyof StorageSchema,
    data: any
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction(storeName, 'readwrite');
      const store = transaction.objectStore(storeName);
      const request = store.put(data);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }
}
```

### 3. Sync Manager

Handles synchronization when connection is restored:

```typescript
interface SyncTask {
  id: string;
  type: 'recipe' | 'collection';
  action: 'create' | 'update' | 'delete';
  data: any;
  retryCount: number;
}

class SyncManager {
  private readonly maxRetries = 3;
  private readonly storage: OfflineStorage;
  private issyncing = false;

  constructor(storage: OfflineStorage) {
    this.storage = storage;
    this.initialize();
  }

  private async initialize(): Promise<void> {
    // Register for online/offline events
    window.addEventListener('online', this.onConnectionRestored);
    window.addEventListener('offline', this.onConnectionLost);

    // Register background sync
    if ('serviceWorker' in navigator && 'sync' in registration) {
      await registration.sync.register('sync-pending-changes');
    }
  }

  async queueSync(task: Omit<SyncTask, 'id' | 'retryCount'>): Promise<void> {
    const syncTask: SyncTask = {
      ...task,
      id: uuid(),
      retryCount: 0
    };

    await this.storage.save('syncQueue', syncTask);

    if (navigator.onLine) {
      await this.processQueue();
    }
  }

  private async processQueue(): Promise<void> {
    if (this.issyncing) return;
    this.issyncing = true;

    try {
      const tasks = await this.storage.getAllFromStore('syncQueue');
      
      for (const task of tasks) {
        try {
          await this.processTask(task);
          await this.storage.deleteFromStore('syncQueue', task.id);
        } catch (error) {
          await this.handleSyncError(task, error);
        }
      }
    } finally {
      this.issyncing = false;
    }
  }

  private async processTask(task: SyncTask): Promise<void> {
    switch (task.type) {
      case 'recipe':
        await this.syncRecipe(task);
        break;
      case 'collection':
        await this.syncCollection(task);
        break;
    }
  }
}
```

### 4. Network Status Manager

Monitors and responds to network status changes:

```typescript
class NetworkManager {
  private isOnline = navigator.onLine;
  private listeners: Set<(online: boolean) => void> = new Set();

  constructor() {
    window.addEventListener('online', () => this.updateStatus(true));
    window.addEventListener('offline', () => this.updateStatus(false));
  }

  addStatusListener(listener: (online: boolean) => void): void {
    this.listeners.add(listener);
    listener(this.isOnline);
  }

  removeStatusListener(listener: (online: boolean) => void): void {
    this.listeners.delete(listener);
  }

  private updateStatus(online: boolean): void {
    this.isOnline = online;
    this.listeners.forEach(listener => listener(online));
  }
}
```

## Offline Video Support

We implement smart video caching for offline viewing:

```typescript
interface VideoCacheConfig {
  maxSize: number;        // Maximum cache size in bytes
  maxVideos: number;      // Maximum number of videos to cache
  quality: 'low' | 'medium' | 'high';
}

class VideoCache {
  private readonly config: VideoCacheConfig;
  private readonly storage: OfflineStorage;

  constructor(config: VideoCacheConfig, storage: OfflineStorage) {
    this.config = config;
    this.storage = storage;
  }

  async cacheVideo(videoId: string): Promise<void> {
    const videoUrl = await this.getVideoUrl(videoId, this.config.quality);
    const response = await fetch(videoUrl);
    const blob = await response.blob();

    // Check cache size limits
    await this.ensureCacheSpace(blob.size);

    // Store video blob
    await this.storage.saveVideo(videoId, blob);
  }

  private async ensureCacheSpace(requiredSize: number): Promise<void> {
    const currentSize = await this.getCurrentCacheSize();
    
    if (currentSize + requiredSize > this.config.maxSize) {
      await this.evictVideos(requiredSize);
    }
  }

  private async evictVideos(requiredSize: number): Promise<void> {
    const videos = await this.storage.getVideosOrderByLastAccess();
    let freedSpace = 0;

    for (const video of videos) {
      if (freedSpace >= requiredSize) break;
      
      await this.storage.deleteVideo(video.id);
      freedSpace += video.size;
    }
  }
}
```

## Error Handling

We implement comprehensive error handling for offline scenarios:

```typescript
class OfflineErrorHandler {
  private readonly networkManager: NetworkManager;

  handleError(error: Error): void {
    if (this.isNetworkError(error)) {
      this.handleNetworkError(error);
    } else if (this.isStorageError(error)) {
      this.handleStorageError(error);
    } else if (this.isSyncError(error)) {
      this.handleSyncError(error);
    } else {
      this.handleUnknownError(error);
    }
  }

  private handleNetworkError(error: Error): void {
    // Show offline notification
    // Enable offline mode
    // Queue pending changes
  }

  private handleStorageError(error: Error): void {
    // Handle storage quota exceeded
    // Clean up unnecessary data
    // Show storage warning
  }

  private handleSyncError(error: Error): void {
    // Retry sync with backoff
    // Show sync status
    // Queue for later retry
  }
}
```

## Performance Optimization

We implement several strategies to optimize offline performance:

1. Progressive Loading
2. Smart Caching
3. Background Sync
4. Compression

```typescript
class PerformanceOptimizer {
  private readonly metrics = {
    cacheHits: 0,
    cacheMisses: 0,
    syncLatency: [],
    storageUsage: 0
  };

  async optimize(): Promise<void> {
    await this.optimizeCache();
    await this.optimizeStorage();
    await this.optimizeSync();
  }

  private async optimizeCache(): Promise<void> {
    // Implement cache optimization logic
  }

  private async optimizeStorage(): Promise<void> {
    // Implement storage optimization logic
  }

  private async optimizeSync(): Promise<void> {
    // Implement sync optimization logic
  }
}
```

This comprehensive offline support system ensures that ReelMeals provides a reliable and performant experience regardless of network connectivity.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/swipe-card.md
================================================
# SwipeCard Component Documentation

## Overview

The SwipeCard component represents an individual video card in our swipe interface. It handles the presentation of video content, manages gesture interactions, and provides visual feedback during swipe actions. This component works in conjunction with the SwipeContainer to create fluid, responsive interactions.

## Implementation

```typescript
interface SwipeCardProps {
  // Video resource to display
  video: VideoResource;
  
  // Current offset from center position
  offset: number;
  
  // Current rotation angle
  rotation: number;
  
  // Gesture handlers
  onSwipeStart: (clientX: number, clientY: number) => void;
  onSwipeMove: (clientX: number, clientY: number) => void;
  onSwipeEnd: () => void;
}

interface VideoResource {
  id: string;
  url: string;
  thumbnail: string;
  metadata: {
    title: string;
    cuisine: string;
    duration: number;
    difficulty: 'Easy' | 'Intermediate' | 'Advanced';
  };
}

const SwipeCard: React.FC<SwipeCardProps> = ({
  video,
  offset,
  rotation,
  onSwipeStart,
  onSwipeMove,
  onSwipeEnd
}) => {
  // Track touch interactions
  const touchRef = useRef<{
    isTouching: boolean;
    startX: number;
    startY: number;
  }>({
    isTouching: false,
    startX: 0,
    startY: 0
  });

  // Handle touch events
  const handleTouchStart = (e: React.TouchEvent) => {
    const touch = e.touches[0];
    touchRef.current = {
      isTouching: true,
      startX: touch.clientX,
      startY: touch.clientY
    };
    onSwipeStart(touch.clientX, touch.clientY);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (!touchRef.current.isTouching) return;
    const touch = e.touches[0];
    onSwipeMove(touch.clientX, touch.clientY);
  };

  const handleTouchEnd = () => {
    touchRef.current.isTouching = false;
    onSwipeEnd();
  };

  // Handle mouse events
  const handleMouseDown = (e: React.MouseEvent) => {
    touchRef.current = {
      isTouching: true,
      startX: e.clientX,
      startY: e.clientY
    };
    onSwipeStart(e.clientX, e.clientY);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!touchRef.current.isTouching) return;
    onSwipeMove(e.clientX, e.clientY);
  };

  const handleMouseUp = () => {
    touchRef.current.isTouching = false;
    onSwipeEnd();
  };

  // Calculate transform based on offset and rotation
  const transform = useMemo(() => {
    return `translate3d(${offset}px, 0, 0) rotate(${rotation}deg)`;
  }, [offset, rotation]);

  return (
    <div
      className="swipe-card"
      style={{
        position: 'absolute',
        width: '100%',
        height: '100%',
        transform,
        transition: touchRef.current.isTouching ? 'none' : 'transform 0.3s ease',
        willChange: 'transform',
        touchAction: 'none'
      }}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
    >
      {/* Video player component */}
      <VideoPlayer
        url={video.url}
        thumbnail={video.thumbnail}
        autoPlay
        muted
        loop
      />

      {/* Metadata overlay */}
      <CardMetadata
        title={video.metadata.title}
        cuisine={video.metadata.cuisine}
        duration={video.metadata.duration}
        difficulty={video.metadata.difficulty}
        swipeProgress={Math.abs(offset) / window.innerWidth}
      />

      {/* Swipe indicators */}
      <SwipeIndicators
        direction={Math.sign(offset)}
        progress={Math.abs(offset) / window.innerWidth}
      />
    </div>
  );
};

interface CardMetadataProps {
  title: string;
  cuisine: string;
  duration: number;
  difficulty: string;
  swipeProgress: number;
}

const CardMetadata: React.FC<CardMetadataProps> = ({
  title,
  cuisine,
  duration,
  difficulty,
  swipeProgress
}) => {
  // Fade out metadata as card is swiped
  const opacity = 1 - swipeProgress;

  return (
    <div 
      className="card-metadata"
      style={{
        position: 'absolute',
        bottom: '20px',
        left: '20px',
        right: '20px',
        opacity
      }}
    >
      <h2 className="text-xl font-bold text-white">{title}</h2>
      <div className="flex gap-2 mt-2">
        <Tag>{cuisine}</Tag>
        <Tag>{formatDuration(duration)}</Tag>
        <Tag>{difficulty}</Tag>
      </div>
    </div>
  );
};

interface SwipeIndicatorsProps {
  direction: number;
  progress: number;
}

const SwipeIndicators: React.FC<SwipeIndicatorsProps> = ({
  direction,
  progress
}) => {
  const opacity = Math.min(progress * 2, 1);
  
  return (
    <>
      {/* Like indicator */}
      <div
        className="like-indicator"
        style={{
          opacity: direction > 0 ? opacity : 0,
          transform: `scale(${1 + progress * 0.5})`
        }}
      >
        <HeartIcon className="w-16 h-16 text-green-500" />
      </div>

      {/* Skip indicator */}
      <div
        className="skip-indicator"
        style={{
          opacity: direction < 0 ? opacity : 0,
          transform: `scale(${1 + progress * 0.5})`
        }}
      >
        <XIcon className="w-16 h-16 text-red-500" />
      </div>
    </>
  );
};
```

## Key Features

1. **Smooth Transformations**: Uses CSS transforms for hardware-accelerated animations, ensuring smooth movement even on lower-end devices.

2. **Touch and Mouse Support**: Handles both touch and mouse events with consistent behavior across devices.

3. **Visual Feedback**: Provides immediate visual feedback through:
   - Card rotation during swipe
   - Like/Skip indicators that fade in based on swipe direction
   - Metadata overlay that fades out during swipe

4. **Performance Optimizations**:
   - Uses `will-change` for transform hints
   - Implements touch event throttling
   - Optimizes re-renders through memoization
   - Uses CSS transitions for non-interactive animations

5. **Accessibility**:
   - Maintains proper focus management
   - Provides keyboard navigation support
   - Includes ARIA labels for interactive elements

The SwipeCard component is designed to work seamlessly with our video player while maintaining smooth performance during interactions. It handles the presentation layer of our swipe interface, leaving the business logic to the parent SwipeContainer component.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/swipe-mechanics.md
================================================
# Swipe Functions Documentation

## Overview

The swipe function system is a crucial component of ReelMeals, providing smooth, intuitive interactions for recipe discovery. This document outlines the implementation details of our swipe mechanics, gesture handling, and animation system.

## Core Components

### 1. Swipe Controller

The SwipeController manages the overall swipe interaction system:

```typescript
interface SwipeControllerConfig {
  threshold: number;          // Distance required for successful swipe
  velocityThreshold: number;  // Speed required for successful swipe
  rotationFactor: number;     // Controls card rotation during swipe
  resistance: number;         // Controls swipe resistance
}

class SwipeController {
  private config: SwipeControllerConfig;
  private state: SwipeState;
  private element: HTMLElement;
  
  constructor(element: HTMLElement, config: SwipeControllerConfig) {
    this.element = element;
    this.config = {
      threshold: 0.4 * window.innerWidth,
      velocityThreshold: 0.5,
      rotationFactor: 15,
      resistance: 1,
      ...config
    };
    
    this.state = {
      isDragging: false,
      startX: 0,
      startY: 0,
      currentX: 0,
      currentY: 0,
      velocity: 0
    };
    
    this.initialize();
  }
  
  private initialize(): void {
    this.setupEventListeners();
    this.setupIntersectionObserver();
  }

  private setupEventListeners(): void {
    // Touch events
    this.element.addEventListener('touchstart', this.handleTouchStart);
    this.element.addEventListener('touchmove', this.handleTouchMove);
    this.element.addEventListener('touchend', this.handleTouchEnd);
    
    // Mouse events
    this.element.addEventListener('mousedown', this.handleMouseDown);
    this.element.addEventListener('mousemove', this.handleMouseMove);
    this.element.addEventListener('mouseup', this.handleMouseUp);
  }
}
```

### 2. Gesture Handler

The GestureHandler processes raw touch and mouse events:

```typescript
interface GestureState {
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  deltaX: number;
  deltaY: number;
  velocity: number;
  direction: 'left' | 'right' | null;
}

class GestureHandler {
  private state: GestureState;
  private readonly velocityTracker: VelocityTracker;
  
  constructor() {
    this.velocityTracker = new VelocityTracker();
    this.state = this.getInitialState();
  }
  
  handleStart(x: number, y: number): void {
    this.state = {
      ...this.getInitialState(),
      startX: x,
      startY: y,
      currentX: x,
      currentY: y
    };
    
    this.velocityTracker.start();
  }
  
  handleMove(x: number, y: number): GestureState {
    const deltaX = x - this.state.startX;
    const deltaY = y - this.state.startY;
    
    this.state = {
      ...this.state,
      currentX: x,
      currentY: y,
      deltaX,
      deltaY,
      velocity: this.velocityTracker.update(x),
      direction: this.getDirection(deltaX)
    };
    
    return this.state;
  }
  
  private getDirection(deltaX: number): 'left' | 'right' | null {
    if (Math.abs(deltaX) < 10) return null;
    return deltaX > 0 ? 'right' : 'left';
  }
}
```

### 3. Animation Manager

The AnimationManager handles smooth transitions and visual feedback:

```typescript
interface AnimationConfig {
  duration: number;
  easing: string;
  springConfig: {
    tension: number;
    friction: number;
  };
}

class AnimationManager {
  private config: AnimationConfig;
  private animation: Animation | null = null;
  
  constructor(config: Partial<AnimationConfig> = {}) {
    this.config = {
      duration: 300,
      easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)',
      springConfig: {
        tension: 120,
        friction: 17
      },
      ...config
    };
  }
  
  animate(element: HTMLElement, properties: Record<string, number>): Promise<void> {
    this.cancelCurrentAnimation();
    
    this.animation = element.animate(
      this.createKeyframes(properties),
      this.createTiming()
    );
    
    return new Promise((resolve) => {
      this.animation!.onfinish = () => {
        this.applyFinalState(element, properties);
        resolve();
      };
    });
  }
  
  private createKeyframes(properties: Record<string, number>): Keyframe[] {
    const currentState = this.getCurrentState(properties);
    return [
      { ...currentState },
      { ...properties }
    ];
  }
  
  private createTiming(): KeyframeAnimationOptions {
    return {
      duration: this.config.duration,
      easing: this.config.easing,
      fill: 'forwards'
    };
  }
}
```

### 4. Velocity Tracker

The VelocityTracker calculates swipe velocity for natural-feeling interactions:

```typescript
interface VelocityFrame {
  position: number;
  timestamp: number;
}

class VelocityTracker {
  private readonly frames: VelocityFrame[] = [];
  private readonly maxFrames = 5;
  
  start(): void {
    this.frames.length = 0;
  }
  
  update(position: number): number {
    const now = performance.now();
    
    this.frames.push({ position, timestamp: now });
    if (this.frames.length > this.maxFrames) {
      this.frames.shift();
    }
    
    return this.calculateVelocity();
  }
  
  private calculateVelocity(): number {
    if (this.frames.length < 2) return 0;
    
    const first = this.frames[0];
    const last = this.frames[this.frames.length - 1];
    
    const deltaTime = last.timestamp - first.timestamp;
    const deltaPosition = last.position - first.position;
    
    return deltaPosition / deltaTime;
  }
}
```

### 5. SwipeCard Component

The SwipeCard component combines all these systems:

```typescript
interface SwipeCardProps {
  video: VideoResource;
  onSwipe: (direction: 'left' | 'right') => Promise<void>;
  isActive: boolean;
}

const SwipeCard: React.FC<SwipeCardProps> = ({
  video,
  onSwipe,
  isActive
}) => {
  const cardRef = useRef<HTMLDivElement>(null);
  const controller = useSwipeController(cardRef, {
    onSwipeLeft: () => onSwipe('left'),
    onSwipeRight: () => onSwipe('right')
  });
  
  const transform = useTransform(controller.x, controller.y, controller.rotation);
  
  return (
    <motion.div
      ref={cardRef}
      className="swipe-card"
      style={{
        position: 'absolute',
        width: '100%',
        height: '100%',
        transform
      }}
      animate={controller.animate}
    >
      <VideoPlayer video={video} isActive={isActive} />
      <SwipeIndicators direction={controller.direction} />
      <CardMetadata video={video} />
    </motion.div>
  );
};
```

## Performance Optimizations

### 1. Hardware Acceleration

We optimize performance through strategic use of hardware acceleration:

```typescript
const optimizeTransforms = (element: HTMLElement) => {
  // Force hardware acceleration
  element.style.transform = 'translate3d(0,0,0)';
  element.style.backfaceVisibility = 'hidden';
  element.style.perspective = '1000px';
  
  // Hint upcoming animations
  element.style.willChange = 'transform';
};
```

### 2. Event Throttling

We implement event throttling to maintain smooth performance:

```typescript
class EventThrottler {
  private timestamp = 0;
  private readonly threshold = 1000 / 60; // 60fps
  
  shouldUpdate(): boolean {
    const now = performance.now();
    
    if (now - this.timestamp >= this.threshold) {
      this.timestamp = now;
      return true;
    }
    
    return false;
  }
}
```

## Error Handling

We implement comprehensive error handling:

```typescript
class SwipeErrorHandler {
  handle(error: Error): void {
    // Log error
    console.error('Swipe error:', error);
    
    // Reset state
    this.resetSwipeState();
    
    // Notify user if necessary
    this.showErrorFeedback();
  }
  
  private resetSwipeState(): void {
    // Reset animation state
    // Reset gesture state
    // Reset velocity tracking
  }
  
  private showErrorFeedback(): void {
    // Show subtle visual feedback
    // Optionally show error message
  }
}
```

## Accessibility

We ensure our swipe interactions are accessible:

```typescript
const AccessibleSwipeCard: React.FC<SwipeCardProps> = (props) => {
  return (
    <div
      role="button"
      tabIndex={0}
      aria-label="Recipe card, swipe right to save, left to skip"
      onKeyDown={handleKeyboardSwipe}
    >
      <SwipeCard {...props} />
    </div>
  );
};
```

This implementation creates a smooth, intuitive swipe interaction system that works well across devices while maintaining high performance and accessibility standards.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/user-preferences.md
================================================
# User Preferences System Documentation

## Overview

The User Preferences System manages personalization settings and user-specific configurations in ReelMeals. This system ensures a customized experience by handling preferences like cuisine types, dietary restrictions, cooking skill levels, and interface settings.

## Core Architecture

### 1. Preference Data Model

```typescript
interface UserPreferences {
  // Cooking Preferences
  cooking: {
    cuisineTypes: string[];
    dietaryRestrictions: string[];
    skillLevel: 'beginner' | 'intermediate' | 'advanced';
    maxCookingTime: number; // in minutes
    servingSizes: number;
    preferredMeasurementSystem: 'metric' | 'imperial';
  };

  // Content Preferences
  content: {
    autoplay: boolean;
    videoQuality: 'auto' | 'low' | 'medium' | 'high';
    captionsEnabled: boolean;
    language: string;
    contentFilters: string[];
  };

  // Interface Preferences
  interface: {
    theme: 'light' | 'dark' | 'system';
    fontSize: number;
    reduceMotion: boolean;
    notificationsEnabled: boolean;
  };

  // Learning Preferences
  learning: {
    difficulty: 'easy' | 'medium' | 'hard';
    recipeComplexity: number;
    ingredientFamiliarity: 'basic' | 'intermediate' | 'advanced';
    techniqueComfort: string[];
  };
}

interface PreferenceMetadata {
  lastUpdated: Timestamp;
  syncStatus: 'synced' | 'pending' | 'conflict';
  version: number;
}
```

### 2. Preferences Manager

The core class managing preference operations:

```typescript
class PreferencesManager {
  private readonly storage: Storage;
  private readonly firestore: Firestore;
  private readonly userId: string;
  private cachedPreferences: UserPreferences | null = null;

  constructor(storage: Storage, firestore: Firestore, userId: string) {
    this.storage = storage;
    this.firestore = firestore;
    this.userId = userId;
  }

  async getPreferences(): Promise<UserPreferences> {
    if (this.cachedPreferences) {
      return this.cachedPreferences;
    }

    // Try local storage first
    const localPrefs = await this.storage.get('userPreferences');
    if (localPrefs) {
      this.cachedPreferences = localPrefs;
      return localPrefs;
    }

    // Fall back to remote preferences
    const remotePrefs = await this.fetchRemotePreferences();
    if (remotePrefs) {
      await this.storage.set('userPreferences', remotePrefs);
      this.cachedPreferences = remotePrefs;
      return remotePrefs;
    }

    // Return defaults if nothing exists
    return this.getDefaultPreferences();
  }

  async updatePreferences(
    updates: Partial<UserPreferences>
  ): Promise<void> {
    const current = await this.getPreferences();
    const updated = this.mergePreferences(current, updates);

    // Update local storage
    await this.storage.set('userPreferences', updated);
    this.cachedPreferences = updated;

    // Queue remote update
    await this.queuePreferenceSync(updated);
  }

  private mergePreferences(
    current: UserPreferences,
    updates: Partial<UserPreferences>
  ): UserPreferences {
    return deepMerge(current, updates);
  }

  private async queuePreferenceSync(
    preferences: UserPreferences
  ): Promise<void> {
    await this.syncQueue.add({
      type: 'preferences',
      action: 'update',
      data: preferences,
      timestamp: Date.now()
    });
  }
}
```

### 3. Preference Validation

We implement strict validation for preferences:

```typescript
class PreferenceValidator {
  private readonly schema: Record<string, ValidationRule>;

  validate(preferences: Partial<UserPreferences>): ValidationResult {
    const errors: ValidationError[] = [];

    for (const [key, value] of Object.entries(preferences)) {
      const rule = this.schema[key];
      if (rule && !rule.validate(value)) {
        errors.push({
          field: key,
          message: rule.message,
          value
        });
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  private readonly schema = {
    'cooking.skillLevel': {
      validate: (value: any) => 
        ['beginner', 'intermediate', 'advanced'].includes(value),
      message: 'Invalid skill level'
    },
    'cooking.maxCookingTime': {
      validate: (value: any) => 
        typeof value === 'number' && value >= 0 && value <= 360,
      message: 'Cooking time must be between 0 and 360 minutes'
    }
    // Additional validation rules...
  };
}
```

### 4. Preference Sync System

Handles synchronization between local and remote preferences:

```typescript
class PreferenceSyncManager {
  private readonly conflictResolver: ConflictResolver;
  private readonly storage: Storage;
  private readonly api: PreferenceAPI;

  async sync(): Promise<void> {
    const localPrefs = await this.storage.get('userPreferences');
    const remotePrefs = await this.api.fetchPreferences();

    if (this.needsSync(localPrefs, remotePrefs)) {
      const resolved = await this.resolveConflicts(localPrefs, remotePrefs);
      await this.applyResolution(resolved);
    }
  }

  private needsSync(
    local: UserPreferences,
    remote: UserPreferences
  ): boolean {
    return local.version !== remote.version;
  }

  private async resolveConflicts(
    local: UserPreferences,
    remote: UserPreferences
  ): Promise<UserPreferences> {
    return this.conflictResolver.resolve(local, remote);
  }

  private async applyResolution(
    resolved: UserPreferences
  ): Promise<void> {
    // Update local storage
    await this.storage.set('userPreferences', resolved);

    // Update remote storage
    await this.api.updatePreferences(resolved);

    // Notify system of changes
    this.notifyPreferenceChange(resolved);
  }
}
```

### 5. Preference-based Personalization

System for applying preferences to content discovery:

```typescript
class PersonalizationEngine {
  private readonly preferences: PreferencesManager;
  private readonly contentFilter: ContentFilter;

  async personalizeContent(
    content: VideoResource[]
  ): Promise<VideoResource[]> {
    const prefs = await this.preferences.getPreferences();
    
    return content
      .filter(video => this.matchesCuisinePreferences(video, prefs))
      .filter(video => this.matchesDietaryRestrictions(video, prefs))
      .filter(video => this.matchesSkillLevel(video, prefs))
      .sort((a, b) => this.calculateRelevanceScore(b, prefs) - 
                      this.calculateRelevanceScore(a, prefs));
  }

  private calculateRelevanceScore(
    video: VideoResource,
    prefs: UserPreferences
  ): number {
    let score = 0;

    // Calculate based on cuisine match
    score += this.calculateCuisineScore(video, prefs);

    // Adjust for skill level match
    score += this.calculateSkillScore(video, prefs);

    // Consider cooking time preference
    score += this.calculateTimeScore(video, prefs);

    return score;
  }
}
```

### 6. Settings UI Components

React components for preference management:

```typescript
interface PreferencesSectionProps {
  title: string;
  description: string;
  preferences: UserPreferences;
  onUpdate: (updates: Partial<UserPreferences>) => Promise<void>;
}

const PreferencesSection: React.FC<PreferencesSectionProps> = ({
  title,
  description,
  preferences,
  onUpdate
}) => {
  return (
    <section className="preferences-section">
      <h2 className="text-xl font-bold">{title}</h2>
      <p className="text-gray-600">{description}</p>

      <div className="preferences-grid">
        {/* Preference controls */}
        <PreferenceControls
          preferences={preferences}
          onUpdate={onUpdate}
        />
      </div>
    </section>
  );
};

const PreferenceControls: React.FC<PreferenceControlsProps> = ({
  preferences,
  onUpdate
}) => {
  const handleChange = async (key: string, value: any) => {
    await onUpdate({ [key]: value });
  };

  return (
    <div className="space-y-4">
      {/* Cuisine Preferences */}
      <MultiSelect
        label="Cuisine Types"
        value={preferences.cooking.cuisineTypes}
        options={CUISINE_OPTIONS}
        onChange={value => handleChange('cooking.cuisineTypes', value)}
      />

      {/* Dietary Restrictions */}
      <MultiSelect
        label="Dietary Restrictions"
        value={preferences.cooking.dietaryRestrictions}
        options={DIETARY_OPTIONS}
        onChange={value => 
          handleChange('cooking.dietaryRestrictions', value)}
      />

      {/* Skill Level */}
      <Select
        label="Skill Level"
        value={preferences.cooking.skillLevel}
        options={SKILL_LEVELS}
        onChange={value => handleChange('cooking.skillLevel', value)}
      />
    </div>
  );
};
```

## Performance Optimization

We implement several optimizations for preference handling:

```typescript
class PreferenceOptimizer {
  private readonly cache: LRUCache<string, any>;

  constructor() {
    this.cache = new LRUCache({
      max: 100,
      maxAge: 1000 * 60 * 5 // 5 minutes
    });
  }

  async optimizePreferenceAccess(): Promise<void> {
    // Implement caching strategy
    await this.cacheFrequentPreferences();

    // Optimize storage
    await this.optimizeStorage();

    // Batch updates
    await this.batchPendingUpdates();
  }
}
```

## Error Handling

Comprehensive error handling for preference operations:

```typescript
class PreferenceErrorHandler {
  handle(error: Error): void {
    if (error instanceof ValidationError) {
      this.handleValidationError(error);
    } else if (error instanceof SyncError) {
      this.handleSyncError(error);
    } else if (error instanceof StorageError) {
      this.handleStorageError(error);
    } else {
      this.handleUnknownError(error);
    }
  }

  private handleValidationError(error: ValidationError): void {
    // Show validation feedback
    // Reset invalid values
    // Suggest corrections
  }

  private handleSyncError(error: SyncError): void {
    // Queue for retry
    // Use local preferences
    // Show sync status
  }
}
```

This comprehensive preference system ensures a personalized, consistent experience across devices while maintaining high performance and reliability.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/features/video-player.md
================================================
# Video Player Feature Documentation

## Overview

The video player is the core component of ReelMeals, providing a seamless, TikTok-style video viewing experience. Our implementation focuses on smooth playback, efficient resource management, and intuitive user interactions. Think of it as a specialized video player designed specifically for cooking content, where users need to clearly see techniques and follow along with recipes.

## Core Functionality

### Video Player Component

The main player component manages video playback and user interactions:

```typescript
interface VideoPlayerProps {
  videoUrl: string;
  metadata: VideoMetadata;
  onComplete: () => void;
  onError: (error: Error) => void;
}

interface VideoMetadata {
  duration: number;
  cuisine: string;
  difficulty: 'Easy' | 'Intermediate' | 'Advanced';
  cookingTime: number;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  videoUrl,
  metadata,
  onComplete,
  onError
}) => {
  // State management for video playback
  const [isPlaying, setIsPlaying] = useState(true);
  const [progress, setProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const videoRef = useRef<HTMLVideoElement>(null);

  // Video load handling
  useEffect(() => {
    const handleLoad = () => {
      setIsLoading(false);
      // Start playback when ready
      videoRef.current?.play().catch(onError);
    };

    const video = videoRef.current;
    if (video) {
      video.addEventListener('loadeddata', handleLoad);
      return () => video.removeEventListener('loadeddata', handleLoad);
    }
  }, [videoUrl]);

  // Progress tracking for completion
  const handleTimeUpdate = () => {
    if (videoRef.current) {
      const currentProgress = 
        videoRef.current.currentTime / videoRef.current.duration;
      setProgress(currentProgress);
      
      if (currentProgress >= 1) {
        onComplete();
      }
    }
  };

  return (
    <div className="video-player-container">
      {/* Loading overlay */}
      {isLoading && <LoadingSpinner />}

      {/* Video element */}
      <video
        ref={videoRef}
        src={videoUrl}
        className="video-element"
        loop
        playsInline
        onTimeUpdate={handleTimeUpdate}
      />

      {/* Metadata overlay */}
      <VideoMetadataOverlay
        metadata={metadata}
        progress={progress}
      />

      {/* Playback controls */}
      <PlaybackControls
        isPlaying={isPlaying}
        onPlayPause={() => setIsPlaying(!isPlaying)}
      />
    </div>
  );
};
```

### Video Loading and Buffering

We implement sophisticated video loading to ensure smooth playback:

```typescript
class VideoLoadManager {
  private loadQueue: VideoResource[] = [];
  private preloadedVideos: Map<string, HTMLVideoElement> = new Map();

  // Configure preloading behavior
  private readonly config = {
    maxPreloadedVideos: 2,
    bufferingGoal: 0.3, // Buffer 30% before starting
    maxRetries: 3
  };

  async preloadVideo(videoUrl: string): Promise<void> {
    // Create a new video element for preloading
    const videoElement = document.createElement('video');
    
    try {
      // Begin loading the video
      videoElement.src = videoUrl;
      videoElement.preload = 'auto';
      
      // Wait for enough data to be loaded
      await new Promise((resolve, reject) => {
        videoElement.addEventListener('canplay', resolve);
        videoElement.addEventListener('error', reject);
      });

      // Store the preloaded video
      this.preloadedVideos.set(videoUrl, videoElement);
      
      // Clean up old preloaded videos if needed
      this.cleanupOldPreloads();
    } catch (error) {
      // Handle loading errors
      console.error('Failed to preload video:', error);
      throw error;
    }
  }

  private cleanupOldPreloads(): void {
    if (this.preloadedVideos.size > this.config.maxPreloadedVideos) {
      const [oldestUrl] = this.preloadedVideos.keys();
      const oldVideo = this.preloadedVideos.get(oldestUrl);
      
      if (oldVideo) {
        oldVideo.src = ''; // Clear the source
        this.preloadedVideos.delete(oldestUrl);
      }
    }
  }
}
```

### Metadata Overlay Component

The metadata overlay provides context about the current video:

```typescript
interface MetadataOverlayProps {
  metadata: VideoMetadata;
  progress: number;
}

const MetadataOverlay: React.FC<MetadataOverlayProps> = ({
  metadata,
  progress
}) => {
  // Position overlay information
  const overlayPosition = useMemo(() => {
    // Calculate optimal position based on video content
    return calculateOverlayPosition(metadata);
  }, [metadata]);

  return (
    <div 
      className="metadata-overlay"
      style={{
        position: 'absolute',
        ...overlayPosition
      }}
    >
      {/* Cuisine type tag */}
      <div className="cuisine-tag">
        {metadata.cuisine}
      </div>

      {/* Cooking time indicator */}
      <div className="time-indicator">
        {formatCookingTime(metadata.cookingTime)}
      </div>

      {/* Difficulty badge */}
      <DifficultyBadge level={metadata.difficulty} />

      {/* Progress indicator */}
      <ProgressBar progress={progress} />
    </div>
  );
};
```

### Progress Tracking and Analytics

We implement comprehensive progress tracking for analytics and user experience:

```typescript
interface VideoAnalytics {
  videoId: string;
  watchDuration: number;
  completionRate: number;
  interactions: UserInteraction[];
}

class VideoAnalyticsTracker {
  private readonly analyticsBuffer: VideoAnalytics[] = [];
  private currentSession: VideoAnalytics | null = null;

  startTracking(videoId: string): void {
    this.currentSession = {
      videoId,
      watchDuration: 0,
      completionRate: 0,
      interactions: []
    };
  }

  updateProgress(progress: number): void {
    if (this.currentSession) {
      this.currentSession.completionRate = progress;
      
      // Buffer analytics data
      if (progress >= 1 || progress % 0.25 === 0) {
        this.bufferAnalytics(this.currentSession);
      }
    }
  }

  private bufferAnalytics(analytics: VideoAnalytics): void {
    this.analyticsBuffer.push({...analytics});
    
    // Flush buffer if it gets too large
    if (this.analyticsBuffer.length >= 10) {
      this.flushAnalytics();
    }
  }

  private async flushAnalytics(): Promise<void> {
    if (this.analyticsBuffer.length > 0) {
      try {
        await this.sendAnalytics(this.analyticsBuffer);
        this.analyticsBuffer.length = 0;
      } catch (error) {
        console.error('Failed to send analytics:', error);
      }
    }
  }
}
```

## Error Handling

We implement robust error handling to ensure a smooth user experience:

```typescript
interface VideoErrorHandler {
  type: 'network' | 'decode' | 'timeout';
  retryCount: number;
  lastError: Error | null;
}

class VideoErrorManager {
  private readonly errorHandlers: Map<string, VideoErrorHandler> = new Map();

  handleError(videoId: string, error: Error): void {
    const handler = this.getOrCreateHandler(videoId);
    
    switch (this.categorizeError(error)) {
      case 'network':
        this.handleNetworkError(handler, videoId);
        break;
      case 'decode':
        this.handleDecodeError(handler, videoId);
        break;
      case 'timeout':
        this.handleTimeoutError(handler, videoId);
        break;
      default:
        this.handleUnknownError(handler, videoId);
    }
  }

  private async handleNetworkError(
    handler: VideoErrorHandler,
    videoId: string
  ): Promise<void> {
    if (handler.retryCount < 3) {
      // Attempt retry with exponential backoff
      await this.retryWithBackoff(handler, videoId);
    } else {
      // Fall back to lower quality version
      await this.fallbackToLowerQuality(videoId);
    }
  }
}
```

## Performance Optimization

We implement several optimizations to ensure smooth playback:

```typescript
interface PerformanceConfig {
  maxConcurrentLoads: number;
  preloadThreshold: number;
  bufferingStrategy: 'eager' | 'lazy';
}

class VideoPerformanceOptimizer {
  private readonly config: PerformanceConfig = {
    maxConcurrentLoads: 2,
    preloadThreshold: 0.8,
    bufferingStrategy: 'eager'
  };

  constructor() {
    this.initializeOptimizer();
  }

  private initializeOptimizer(): void {
    // Set up performance monitoring
    this.setupPerformanceObserver();
    
    // Initialize memory management
    this.setupMemoryManagement();
  }

  private setupPerformanceObserver(): void {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.handlePerformanceEntry(entry);
      }
    });

    observer.observe({ entryTypes: ['video'] });
  }
}
```

This documentation provides a comprehensive overview of our video player implementation, focusing on the key aspects that ensure a smooth and engaging user experience. Each component is designed to work together seamlessly while maintaining high performance and reliability.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/setup/deployment.md
================================================
# Deployment Procedures

## Introduction

This document outlines our deployment procedures for ReelMeals. We use a staged deployment approach with multiple environments to ensure reliability and minimize risks when pushing updates to production. Our application uses Firebase Hosting for static content and Cloud Functions for server-side functionality, while leveraging Next.js for the application framework.

## Environment Configuration

We maintain three distinct environments to support our deployment pipeline. Each environment has its own Firebase project and configuration:

### Development Environment
```typescript
// .env.development
NEXT_PUBLIC_FIREBASE_PROJECT_ID=reelmeals-dev
NEXT_PUBLIC_API_URL=https://api-dev.reelmeals.app
NEXT_PUBLIC_STORAGE_BUCKET=reelmeals-dev.appspot.com
NEXT_PUBLIC_ENABLE_ANALYTICS=false
```

### Staging Environment
```typescript
// .env.staging
NEXT_PUBLIC_FIREBASE_PROJECT_ID=reelmeals-staging
NEXT_PUBLIC_API_URL=https://api-staging.reelmeals.app
NEXT_PUBLIC_STORAGE_BUCKET=reelmeals-staging.appspot.com
NEXT_PUBLIC_ENABLE_ANALYTICS=true
```

### Production Environment
```typescript
// .env.production
NEXT_PUBLIC_FIREBASE_PROJECT_ID=reelmeals-prod
NEXT_PUBLIC_API_URL=https://api.reelmeals.app
NEXT_PUBLIC_STORAGE_BUCKET=reelmeals-prod.appspot.com
NEXT_PUBLIC_ENABLE_ANALYTICS=true
```

## Build Configuration

Our build process is configured to optimize for production performance:

```javascript
// next.config.js
module.exports = {
  // Enable production source maps for better error tracking
  productionBrowserSourceMaps: true,
  
  // Configure image optimization
  images: {
    domains: [
      'storage.googleapis.com',
      'firebasestorage.googleapis.com'
    ],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 60
  },
  
  // Configure build output
  output: 'standalone',
  
  // Configure webpack for optimal bundling
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
    // Add build-time optimizations
    if (!dev && !isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        minSize: 20000,
        maxSize: 244000,
        minChunks: 1,
        maxAsyncRequests: 30,
        maxInitialRequests: 30,
        cacheGroups: {
          default: false,
          vendors: false,
          framework: {
            chunks: 'all',
            name: 'framework',
            test: /[\\/]node_modules[\\/]/,
            priority: 40,
            enforce: true
          },
          lib: {
            test(module) {
              return (
                module.size() > 160000 &&
                /node_modules[/\\]/.test(module.identifier())
              );
            },
            name(module) {
              const hash = crypto.createHash('sha1');
              hash.update(module.identifier());
              return hash.digest('hex').substring(0, 8);
            },
            priority: 30,
            minChunks: 1,
            reuseExistingChunk: true
          }
        }
      };
    }
    return config;
  }
};
```

## Deployment Scripts

We use custom deployment scripts to automate our deployment process:

```bash
#!/bin/bash
# deploy.sh

# Validate environment argument
ENV=$1
if [[ ! $ENV =~ ^(staging|production)$ ]]; then
  echo "Invalid environment. Use 'staging' or 'production'"
  exit 1
fi

# Load environment variables
source .env.$ENV

# Build application
echo "Building for $ENV environment..."
npm run build

# Run pre-deployment tests
echo "Running pre-deployment tests..."
npm run test:e2e

# Deploy to Firebase
echo "Deploying to Firebase..."
firebase use $NEXT_PUBLIC_FIREBASE_PROJECT_ID
firebase deploy --only hosting,functions

# Run post-deployment checks
echo "Running post-deployment checks..."
./scripts/post-deploy-checks.sh $ENV

# Notify team
./scripts/notify-deployment.sh $ENV
```

## Deployment Pipeline

Our deployment pipeline follows these steps:

### 1. Pre-deployment Checks

```typescript
// scripts/pre-deploy-checks.ts
async function runPreDeploymentChecks() {
  const checks = [
    checkDependencies(),
    validateEnvironmentVariables(),
    runSecurityChecks(),
    checkDatabaseMigrations()
  ];

  const results = await Promise.all(checks);
  return results.every(result => result.passed);
}

async function checkDependencies() {
  // Verify all dependencies are correctly installed
  const output = await exec('npm audit');
  return {
    passed: !output.includes('high') && !output.includes('critical'),
    details: output
  };
}

async function validateEnvironmentVariables() {
  // Verify all required environment variables are set
  const requiredVars = [
    'NEXT_PUBLIC_FIREBASE_PROJECT_ID',
    'NEXT_PUBLIC_API_URL',
    'NEXT_PUBLIC_STORAGE_BUCKET'
  ];

  const missingVars = requiredVars.filter(
    varName => !process.env[varName]
  );

  return {
    passed: missingVars.length === 0,
    details: missingVars
  };
}
```

### 2. Build Process

```typescript
// scripts/build.ts
async function buildApplication() {
  try {
    // Clean previous build
    await exec('rm -rf .next out');

    // Install dependencies
    await exec('npm ci');

    // Run type checks
    await exec('tsc --noEmit');

    // Build application
    await exec('next build');

    // Run post-build optimizations
    await optimizeBuild();

    return true;
  } catch (error) {
    console.error('Build failed:', error);
    return false;
  }
}

async function optimizeBuild() {
  // Optimize images
  await exec('next-image-optimize');

  // Analyze bundle size
  await exec('next-bundle-analyzer');
}
```

### 3. Deployment Process

```typescript
// scripts/deploy.ts
async function deploy(environment: 'staging' | 'production') {
  try {
    // Switch Firebase project
    await exec(`firebase use ${environment}`);

    // Deploy hosting
    await exec('firebase deploy --only hosting');

    // Deploy functions
    await exec('firebase deploy --only functions');

    // Deploy Firestore rules
    await exec('firebase deploy --only firestore:rules');

    // Deploy Storage rules
    await exec('firebase deploy --only storage:rules');

    return true;
  } catch (error) {
    console.error('Deployment failed:', error);
    return false;
  }
}
```

### 4. Post-deployment Verification

```typescript
// scripts/verify-deployment.ts
async function verifyDeployment(environment: string) {
  const checks = [
    checkApplicationHealth(),
    checkDatabaseConnectivity(),
    checkStorageAccess(),
    checkAuthenticationFlow(),
    checkVideoPlayback()
  ];

  const results = await Promise.allSettled(checks);
  return results.every(result => result.status === 'fulfilled');
}

async function checkApplicationHealth() {
  const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/health`);
  return response.status === 200;
}

async function checkVideoPlayback() {
  // Verify video streaming functionality
  const testVideoId = 'test-video-id';
  const result = await testVideoStream(testVideoId);
  return result.success;
}
```

## Rollback Procedures

In case of deployment issues, we have automated rollback procedures:

```typescript
// scripts/rollback.ts
async function rollback(environment: string) {
  try {
    // Get previous successful deployment
    const previousDeployment = await getPreviousDeployment(environment);

    // Revert to previous version
    await exec(
      `firebase hosting:clone ${previousDeployment.version} ${environment}`
    );

    // Revert functions
    await exec(
      `firebase functions:rollback ${previousDeployment.functionsVersion}`
    );

    // Verify rollback
    const verified = await verifyDeployment(environment);
    if (!verified) {
      throw new Error('Rollback verification failed');
    }

    return true;
  } catch (error) {
    console.error('Rollback failed:', error);
    return false;
  }
}
```

## Monitoring and Alerts

We use Firebase Performance Monitoring to track deployment health:

```typescript
// src/config/monitoring.ts
import { getPerformance } from 'firebase/performance';

const performance = getPerformance(app);

// Configure custom traces
const deploymentTraces = {
  pageLoad: performance.trace('page_load'),
  videoLoad: performance.trace('video_load'),
  apiLatency: performance.trace('api_latency')
};

// Monitor deployment health
export const monitorDeployment = () => {
  deploymentTraces.pageLoad.start();
  
  // Set custom attributes
  deploymentTraces.pageLoad.putAttribute(
    'deployment_version',
    process.env.NEXT_PUBLIC_BUILD_ID
  );
  
  // Record metrics
  window.addEventListener('load', () => {
    deploymentTraces.pageLoad.stop();
  });
};
```

## Security Considerations

During deployment, we implement several security measures:

1. Validate all environment variables
2. Deploy updated security rules
3. Rotate service account keys
4. Update API keys if necessary
5. Verify CORS configurations

## Continuous Integration

Our CI pipeline automates many deployment tasks:

```yaml
# .github/workflows/deploy.yml
name: Deploy
on:
  push:
    branches:
      - main
      - staging

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
          
      - name: Install Dependencies
        run: npm ci
        
      - name: Run Tests
        run: npm test
        
      - name: Build
        run: npm run build
        
      - name: Deploy to Firebase
        uses: firebase/firebase-tools-action@v1
        with:
          args: deploy --only hosting,functions
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
```

Remember to follow these deployment procedures carefully and always verify each step before proceeding to the next. This ensures a smooth and reliable deployment process while maintaining application stability.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/setup/development.md
================================================
# Development Environment Setup

## Prerequisites

```bash
# Required versions
Node.js >= 18.0.0
npm >= 9.0.0
Firebase CLI >= 12.0.0
```

## Initial Setup

```bash
# Install global dependencies
npm install -g firebase-tools

# Clone repository
git clone https://github.com/reelmeals/reelmeals-app.git
cd reelmeals-app

# Install project dependencies
npm install
```

## Firebase Configuration

```typescript
// src/config/firebase.ts
export const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

export { app, db, auth, storage };
```

## Environment Setup

Create `.env.local`:

```bash
# Firebase Config
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_auth_domain
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_storage_bucket
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# API Keys
NEXT_PUBLIC_VIDEO_PROCESSING_API_KEY=your_api_key
NEXT_PUBLIC_ANALYTICS_KEY=your_analytics_key

# Feature Flags
NEXT_PUBLIC_ENABLE_VIDEO_PROCESSING=true
NEXT_PUBLIC_ENABLE_AI_FEATURES=true
```

## Firebase Emulator Setup

```bash
# Install and configure emulators
firebase init emulators

# Start emulators
firebase emulators:start
```

Configure emulator connection:

```typescript
// src/config/firebase.ts
if (process.env.NODE_ENV === 'development') {
  connectFirestoreEmulator(db, 'localhost', 8080);
  connectAuthEmulator(auth, 'http://localhost:9099');
  connectStorageEmulator(storage, 'localhost', 9199);
}
```

## Development Scripts

Add to `package.json`:

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "emulators": "firebase emulators:start",
    "dev:emulator": "concurrently \"npm run dev\" \"npm run emulators\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "cypress": "cypress open",
    "cypress:headless": "cypress run"
  }
}
```

## VS Code Configuration

Create `.vscode/settings.json`:

```json
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}
```

## Git Configuration

Create `.gitignore`:

```bash
# Dependencies
node_modules
.pnp
.pnp.js

# Testing
coverage

# Next.js
.next/
out/

# Environment
.env*.local
.env.development
.env.test
.env.production

# Firebase
.firebase/
*-debug.log

# IDE
.vscode/*
!.vscode/settings.json
.idea

# OS
.DS_Store
*.pem
```

## Testing Setup

Configure Jest in `jest.config.js`:

```javascript
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './'
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/components/(.*)$': '<rootDir>/components/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1'
  },
  testEnvironment: 'jest-environment-jsdom'
};

module.exports = createJestConfig(customJestConfig);
```

## Development Tools

Install recommended VS Code extensions:

- ESLint
- Prettier
- Firebase Explorer
- Jest Runner
- GitLens
- Tailwind CSS IntelliSense

## Local Development Workflow

1. Start development server:
```bash
npm run dev:emulator
```

2. Access development environment:
- Web app: http://localhost:3000
- Firebase Emulator UI: http://localhost:4000
- Firestore Emulator: http://localhost:8080
- Auth Emulator: http://localhost:9099
- Storage Emulator: http://localhost:9199

## Troubleshooting

Common issues and solutions:

```bash
# Reset emulators
firebase emulators:stop
rm -rf .firebase/emulators

# Clear Next.js cache
rm -rf .next
npm run dev

# Reset Firebase cache
firebase logout
firebase login
```

## Performance Monitoring

Enable Firebase Performance Monitoring:

```typescript
// src/config/firebase.ts
import { getPerformance } from 'firebase/performance';

const performance = getPerformance(app);
export { performance };
```

## Security Best Practices

1. Use environment variables for sensitive data
2. Enable Firebase Security Rules
3. Implement proper authentication checks
4. Use TypeScript for type safety
5. Regular dependency updates

## Development Guidelines

1. Follow Git branch naming convention:
```
feature/feature-name
bugfix/bug-description
hotfix/issue-description
```

2. Commit message format:
```
type(scope): description

[optional body]
[optional footer]
```

3. Run tests before committing:
```bash
npm run test
npm run cypress:headless
```

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/setup/firebase.md
================================================
# Development Environment Setup

## Prerequisites

```bash
# Required versions
Node.js >= 18.0.0
npm >= 9.0.0
Firebase CLI >= 12.0.0
```

## Initial Setup

```bash
# Install global dependencies
npm install -g firebase-tools

# Clone repository
git clone https://github.com/reelmeals/reelmeals-app.git
cd reelmeals-app

# Install project dependencies
npm install
```

## Firebase Configuration

```typescript
// src/config/firebase.ts
export const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

export { app, db, auth, storage };
```

## Environment Setup

Create `.env.local`:

```bash
# Firebase Config
NEXT_PUBLIC_FIREBASE_API_KEY=your_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_auth_domain
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_storage_bucket
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# API Keys
NEXT_PUBLIC_VIDEO_PROCESSING_API_KEY=your_api_key
NEXT_PUBLIC_ANALYTICS_KEY=your_analytics_key

# Feature Flags
NEXT_PUBLIC_ENABLE_VIDEO_PROCESSING=true
NEXT_PUBLIC_ENABLE_AI_FEATURES=true
```

## Firebase Emulator Setup

```bash
# Install and configure emulators
firebase init emulators

# Start emulators
firebase emulators:start
```

Configure emulator connection:

```typescript
// src/config/firebase.ts
if (process.env.NODE_ENV === 'development') {
  connectFirestoreEmulator(db, 'localhost', 8080);
  connectAuthEmulator(auth, 'http://localhost:9099');
  connectStorageEmulator(storage, 'localhost', 9199);
}
```

## Development Scripts

Add to `package.json`:

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "emulators": "firebase emulators:start",
    "dev:emulator": "concurrently \"npm run dev\" \"npm run emulators\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "cypress": "cypress open",
    "cypress:headless": "cypress run"
  }
}
```

## VS Code Configuration

Create `.vscode/settings.json`:

```json
{
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}
```

## Git Configuration

Create `.gitignore`:

```bash
# Dependencies
node_modules
.pnp
.pnp.js

# Testing
coverage

# Next.js
.next/
out/

# Environment
.env*.local
.env.development
.env.test
.env.production

# Firebase
.firebase/
*-debug.log

# IDE
.vscode/*
!.vscode/settings.json
.idea

# OS
.DS_Store
*.pem
```

## Testing Setup

Configure Jest in `jest.config.js`:

```javascript
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './'
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/components/(.*)$': '<rootDir>/components/$1',
    '^@/lib/(.*)$': '<rootDir>/lib/$1'
  },
  testEnvironment: 'jest-environment-jsdom'
};

module.exports = createJestConfig(customJestConfig);
```

## Development Tools

Install recommended VS Code extensions:

- ESLint
- Prettier
- Firebase Explorer
- Jest Runner
- GitLens
- Tailwind CSS IntelliSense

## Local Development Workflow

1. Start development server:
```bash
npm run dev:emulator
```

2. Access development environment:
- Web app: http://localhost:3000
- Firebase Emulator UI: http://localhost:4000
- Firestore Emulator: http://localhost:8080
- Auth Emulator: http://localhost:9099
- Storage Emulator: http://localhost:9199

## Troubleshooting

Common issues and solutions:

```bash
# Reset emulators
firebase emulators:stop
rm -rf .firebase/emulators

# Clear Next.js cache
rm -rf .next
npm run dev

# Reset Firebase cache
firebase logout
firebase login
```

## Performance Monitoring

Enable Firebase Performance Monitoring:

```typescript
// src/config/firebase.ts
import { getPerformance } from 'firebase/performance';

const performance = getPerformance(app);
export { performance };
```

## Security Best Practices

1. Use environment variables for sensitive data
2. Enable Firebase Security Rules
3. Implement proper authentication checks
4. Use TypeScript for type safety
5. Regular dependency updates

## Development Guidelines

1. Follow Git branch naming convention:
```
feature/feature-name
bugfix/bug-description
hotfix/issue-description
```

2. Commit message format:
```
type(scope): description

[optional body]
[optional footer]
```

3. Run tests before committing:
```bash
npm run test
npm run cypress:headless
```

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/testing/accessibility.md
================================================
# Accessibility Documentation

## Overview

ReelMeals prioritizes accessibility by building on the strong foundation provided by shadcn/ui and Radix Primitives. This document explains how we ensure our video-centric application remains accessible to all users, combining the built-in accessibility features of our UI libraries with additional considerations specific to video content.

## Foundation: shadcn/ui and Radix

Our application builds on shadcn/ui, which uses Radix Primitives underneath. These libraries provide several key accessibility features out of the box:

### Built-in Accessibility Features

```typescript
// Example of a accessible video control using shadcn/ui Button
import { Button } from "@/components/ui/button"
import { Play, Pause } from "lucide-react"

const VideoControlButton = ({
  isPlaying,
  onToggle,
  label
}: VideoControlProps) => {
  return (
    <Button
      // Radix handles ARIA attributes automatically
      variant="ghost"
      size="icon"
      onClick={onToggle}
      // Additional accessibility attributes
      aria-pressed={isPlaying}
      aria-label={label}
    >
      {isPlaying ? <Pause /> : <Play />}
    </Button>
  );
};
```

### Keyboard Navigation

Radix Primitives provide comprehensive keyboard support:

```typescript
// Example using Radix's Slider for video progress
import * as Slider from '@radix-ui/react-slider';

const VideoProgress = ({
  duration,
  currentTime,
  onSeek
}: VideoProgressProps) => {
  return (
    <Slider.Root
      // Keyboard step values
      step={1}
      min={0}
      max={duration}
      value={[currentTime]}
      onValueChange={([value]) => onSeek(value)}
      // Additional accessibility features
      aria-label="Video progress"
      // Custom styling using tailwind
      className="relative flex items-center w-full h-5"
    >
      <Slider.Track className="bg-secondary relative grow h-1">
        <Slider.Range className="absolute bg-primary h-full" />
      </Slider.Track>
      <Slider.Thumb className="block w-3 h-3 bg-primary rounded-full" />
    </Slider.Root>
  );
};
```

## Video-Specific Accessibility

While shadcn/ui and Radix handle many accessibility concerns, video content requires additional considerations:

### Captions and Transcripts

```typescript
interface CaptionConfig {
  // Supported caption formats
  formats: {
    webvtt: boolean;
    srt: boolean;
    ttml: boolean;
  };
  // Caption styling options
  styling: {
    position: 'overlay' | 'below';
    fontSize: string;
    background: string;
    textColor: string;
  };
}

const VideoCaptioning = ({
  videoId,
  language = 'en'
}: VideoCaptioningProps) => {
  const [captions, setCaptions] = useState<Caption[]>([]);
  const [activeCue, setActiveCue] = useState<Caption | null>(null);

  useEffect(() => {
    // Load captions for the current video
    loadCaptions(videoId, language);
  }, [videoId, language]);

  return (
    <div 
      role="region" 
      aria-label="Video captions"
      className="caption-container"
    >
      {activeCue && (
        <div className="caption-text">
          {activeCue.text}
        </div>
      )}
    </div>
  );
};
```

### Media Controls

We extend shadcn/ui's components to create accessible media controls:

```typescript
const AccessibleVideoControls = ({
  videoState,
  onTogglePlay,
  onSeek,
  onVolumeChange
}: VideoControlsProps) => {
  // Use shadcn/ui components with additional accessibility features
  return (
    <div
      role="region"
      aria-label="Video controls"
      className="video-controls"
    >
      {/* Play/Pause Button */}
      <Button
        variant="ghost"
        size="icon"
        onClick={onTogglePlay}
        aria-label={videoState.isPlaying ? 'Pause video' : 'Play video'}
      >
        {videoState.isPlaying ? <Pause /> : <Play />}
      </Button>

      {/* Volume Control using Radix Slider */}
      <Slider.Root
        defaultValue={[100]}
        max={100}
        step={1}
        aria-label="Volume"
        onValueChange={onVolumeChange}
      >
        <Slider.Track>
          <Slider.Range />
        </Slider.Track>
        <Slider.Thumb />
      </Slider.Root>

      {/* Additional controls... */}
    </div>
  );
};
```

### Keyboard Shortcuts

We implement comprehensive keyboard controls:

```typescript
const VideoKeyboardControls = ({
  videoRef,
  onCommand
}: VideoKeyboardProps) => {
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      // Prevent default only for our specific shortcuts
      if (shouldPreventDefault(event.key)) {
        event.preventDefault();
      }

      switch (event.key.toLowerCase()) {
        case ' ':
          onCommand('togglePlay');
          break;
        case 'k':
          onCommand('togglePlay');
          break;
        case 'm':
          onCommand('toggleMute');
          break;
        case 'f':
          onCommand('toggleFullscreen');
          break;
        case 'arrowright':
          onCommand('seekForward');
          break;
        case 'arrowleft':
          onCommand('seekBackward');
          break;
        case 'arrowup':
          onCommand('volumeUp');
          break;
        case 'arrowdown':
          onCommand('volumeDown');
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [onCommand]);

  return null; // This is a behavior-only component
};
```

### Focus Management

We implement custom focus management for video interactions:

```typescript
const VideoFocusManager = ({ children }: { children: React.ReactNode }) => {
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Trap focus within video controls when they're visible
  const trapFocus = useCallback((event: KeyboardEvent) => {
    if (!containerRef.current) return;
    
    const focusableElements = containerRef.current.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[
      focusableElements.length - 1
    ] as HTMLElement;
    
    if (event.key === 'Tab') {
      if (event.shiftKey) {
        if (document.activeElement === firstElement) {
          lastElement.focus();
          event.preventDefault();
        }
      } else {
        if (document.activeElement === lastElement) {
          firstElement.focus();
          event.preventDefault();
        }
      }
    }
  }, []);
  
  useEffect(() => {
    window.addEventListener('keydown', trapFocus);
    return () => window.removeEventListener('keydown', trapFocus);
  }, [trapFocus]);
  
  return (
    <div ref={containerRef} className="focus-container">
      {children}
    </div>
  );
};
```

### Screen Reader Announcements

We provide contextual screen reader announcements for video events:

```typescript
const VideoAnnouncements = ({
  videoState,
  onStateChange
}: VideoAnnouncementsProps) => {
  const prevState = useRef(videoState);
  
  useEffect(() => {
    // Only announce meaningful changes
    if (videoState !== prevState.current) {
      const message = getAnnouncementMessage(videoState);
      announceToScreenReader(message);
      prevState.current = videoState;
    }
  }, [videoState]);
  
  const getAnnouncementMessage = (state: VideoState): string => {
    switch (state) {
      case 'playing':
        return 'Video is now playing';
      case 'paused':
        return 'Video paused';
      case 'buffering':
        return 'Video is buffering';
      case 'error':
        return 'Error playing video. Please try again.';
      default:
        return '';
    }
  };
  
  const announceToScreenReader = (message: string) => {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.classList.add('sr-only');
    announcement.textContent = message;
    document.body.appendChild(announcement);
    
    // Remove after announcement is made
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  };
  
  return null; // This is a behavior-only component
};
```

### Motion Reduction

We respect user motion preferences:

```typescript
const VideoTransitions = () => {
  // Check user's motion preference
  const prefersReducedMotion = window.matchMedia(
    '(prefers-reduced-motion: reduce)'
  ).matches;
  
  const transitionStyles = {
    // Conditional animations based on user preference
    transition: prefersReducedMotion 
      ? 'none' 
      : 'all 0.3s ease-in-out',
    // Use opacity for smoother transitions
    opacity: prefersReducedMotion ? 1 : 0.8
  };
  
  return transitionStyles;
};
```

## Testing Accessibility

We implement automated accessibility testing alongside our regular test suite:

```typescript
// tests/accessibility.test.tsx
import { axe } from 'jest-axe';

describe('Video Player Accessibility', () => {
  it('should not have any WCAG violations', async () => {
    const { container } = render(<VideoPlayer videoId="test-video" />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('should be keyboard navigable', () => {
    render(<VideoPlayer videoId="test-video" />);
    
    // Test keyboard navigation
    userEvent.tab();
    expect(screen.getByRole('button', { name: /play/i }))
      .toHaveFocus();
    
    userEvent.tab();
    expect(screen.getByRole('slider', { name: /volume/i }))
      .toHaveFocus();
  });
});
```

## Best Practices

1. Always use semantic HTML elements
2. Maintain proper heading hierarchy
3. Provide text alternatives for visual content
4. Ensure sufficient color contrast
5. Support keyboard navigation
6. Respect user preferences for motion and animations
7. Test with screen readers regularly
8. Keep ARIA labels clear and concise

This comprehensive approach to accessibility ensures that our video application is usable by all users, regardless of their abilities or assistive technology needs.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/testing/performance.md
================================================
# Performance Testing Documentation

## Overview

This document outlines our performance testing strategy for ReelMeals. As a video-centric application, performance testing focuses on three critical areas: video streaming performance, interaction responsiveness, and system resource utilization. Our goal is to ensure a smooth, high-quality user experience across different devices and network conditions.

## Core Performance Metrics

### 1. Video Performance Metrics

```typescript
interface VideoMetrics {
  // Time until video starts playing
  startupTime: {
    target: number;    // Target: < 2 seconds
    p95: number;       // 95th percentile target: < 3 seconds
    measurement: 'milliseconds';
  };
  
  // Time spent buffering vs. total playback time
  bufferingRatio: {
    target: number;    // Target: < 0.5%
    p95: number;       // 95th percentile target: < 1%
    measurement: 'percentage';
  };
  
  // Video quality switches during playback
  qualityChanges: {
    target: number;    // Target: < 2 per minute
    measurement: 'changes/minute';
  };
  
  // Frame delivery performance
  playbackMetrics: {
    fps: number;       // Target: > 25fps
    droppedFrames: number;  // Target: < 1%
    measurement: 'frames/second';
  };
}

class VideoPerformanceMonitor {
  private metrics: VideoMetrics = {
    startupTime: {
      target: 2000,
      p95: 3000,
      measurement: 'milliseconds'
    },
    bufferingRatio: {
      target: 0.5,
      p95: 1,
      measurement: 'percentage'
    },
    qualityChanges: {
      target: 2,
      measurement: 'changes/minute'
    },
    playbackMetrics: {
      fps: 30,
      droppedFrames: 1,
      measurement: 'frames/second'
    }
  };

  async measureVideoPerformance(videoId: string): Promise<VideoMetrics> {
    const videoElement = document.querySelector('video');
    const measurements = {
      startupTime: await this.measureStartupTime(videoElement),
      bufferingRatio: await this.measureBufferingRatio(videoElement),
      qualityChanges: await this.measureQualityChanges(videoElement),
      playbackMetrics: await this.measurePlaybackMetrics(videoElement)
    };

    return this.analyzeMetrics(measurements);
  }
}
```

### 2. Interaction Performance

```typescript
interface InteractionMetrics {
  // Time from swipe to next video ready
  swipeLatency: {
    target: number;    // Target: < 100ms
    measurement: 'milliseconds';
  };
  
  // Time until UI responds to touch
  touchResponseTime: {
    target: number;    // Target: < 16ms (60fps)
    measurement: 'milliseconds';
  };
  
  // Animation smoothness
  animationFrameRate: {
    target: number;    // Target: 60fps
    measurement: 'frames/second';
  };
}

class InteractionPerformanceTester {
  async measureSwipePerformance(): Promise<void> {
    const results = await this.runSwipeTests({
      iterations: 100,
      directions: ['left', 'right'],
      swipeVelocities: ['slow', 'medium', 'fast']
    });

    this.analyzeSwipeResults(results);
  }

  private async runSwipeTests(config: SwipeTestConfig): Promise<SwipeResults> {
    const measurements: SwipeMeasurement[] = [];

    for (const direction of config.directions) {
      for (const velocity of config.swipeVelocities) {
        for (let i = 0; i < config.iterations; i++) {
          const result = await this.performSwipe({
            direction,
            velocity,
            startPosition: this.getRandomStartPosition()
          });
          measurements.push(result);
        }
      }
    }

    return this.aggregateResults(measurements);
  }
}
```

### 3. Resource Utilization Testing

```typescript
interface ResourceMetrics {
  memory: {
    heapSize: number;
    heapLimit: number;
    externalMemory: number;
  };
  cpu: {
    usage: number;
    tasks: number;
  };
  network: {
    bandwidth: number;
    requests: number;
    cacheHits: number;
  };
}

class ResourceMonitor {
  private readonly limits = {
    memory: {
      heap: 100 * 1024 * 1024,  // 100MB
      external: 50 * 1024 * 1024 // 50MB
    },
    cpu: {
      maxUsage: 80,  // 80%
      maxTasks: 5
    },
    network: {
      maxBandwidth: 5 * 1024 * 1024  // 5MB/s
    }
  };

  async monitorResourceUsage(
    duration: number
  ): Promise<ResourceMetrics[]> {
    const measurements: ResourceMetrics[] = [];
    const interval = 1000;  // 1 second intervals
    
    for (let i = 0; i < duration; i += interval) {
      measurements.push({
        memory: await this.measureMemory(),
        cpu: await this.measureCPU(),
        network: await this.measureNetwork()
      });
      
      await new Promise(resolve => setTimeout(resolve, interval));
    }

    return measurements;
  }
}
```

## Load Testing

### 1. Concurrent Video Streaming

```typescript
class StreamLoadTester {
  async testConcurrentStreams(
    config: StreamTestConfig
  ): Promise<StreamTestResults> {
    const { maxConcurrent, duration, rampUpTime } = config;
    const results: StreamTestResults = {
      successfulStreams: 0,
      failedStreams: 0,
      avgLatency: 0,
      peakBandwidth: 0
    };

    // Create virtual users
    const users = Array.from(
      { length: maxConcurrent },
      (_, i) => this.createVirtualUser(i)
    );

    // Ramp up load
    const usersPerBatch = Math.ceil(maxConcurrent / (rampUpTime / 1000));
    for (let i = 0; i < users.length; i += usersPerBatch) {
      const batch = users.slice(i, i + usersPerBatch);
      await Promise.all(batch.map(user => user.startStreaming()));
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // Monitor performance
    const metrics = await this.monitorStreamingMetrics(duration);
    return this.analyzeLoadTestResults(metrics);
  }
}
```

### 2. Data Store Performance

```typescript
class DatabaseLoadTester {
  async testFirestorePerformance(
    config: DBTestConfig
  ): Promise<DBTestResults> {
    const operations = this.generateTestOperations(config);
    const results: OperationResult[] = [];

    // Execute operations with monitoring
    for (const operation of operations) {
      const result = await this.executeOperation(operation);
      results.push(result);

      // Check for performance degradation
      if (this.hasPerformanceDegraded(results)) {
        await this.handleDegradation(results);
      }
    }

    return this.analyzeDBResults(results);
  }

  private generateTestOperations(
    config: DBTestConfig
  ): DBOperation[] {
    return [
      // Read operations
      {
        type: 'read',
        pattern: 'sequential',
        count: config.readCount
      },
      // Write operations
      {
        type: 'write',
        pattern: 'random',
        count: config.writeCount
      },
      // Query operations
      {
        type: 'query',
        pattern: 'complex',
        count: config.queryCount
      }
    ];
  }
}
```

## Network Condition Testing

```typescript
class NetworkSimulator {
  private readonly conditions = {
    '4g': {
      latency: 100,
      downloadSpeed: 4 * 1024 * 1024,
      uploadSpeed: 1 * 1024 * 1024,
      packetLoss: 0.1
    },
    '3g': {
      latency: 250,
      downloadSpeed: 750 * 1024,
      uploadSpeed: 250 * 1024,
      packetLoss: 0.5
    },
    'slow-3g': {
      latency: 400,
      downloadSpeed: 400 * 1024,
      uploadSpeed: 100 * 1024,
      packetLoss: 1
    }
  };

  async testNetworkResilience(): Promise<NetworkTestResults> {
    const results: NetworkTestResults = {};

    for (const [condition, params] of Object.entries(this.conditions)) {
      // Configure network condition
      await this.setNetworkCondition(params);

      // Test video streaming
      const streamResults = await this.testVideoStreaming();
      
      // Test interaction latency
      const interactionResults = await this.testInteractions();
      
      // Test error recovery
      const recoveryResults = await this.testErrorRecovery();

      results[condition] = {
        streaming: streamResults,
        interaction: interactionResults,
        recovery: recoveryResults
      };
    }

    return results;
  }
}
```

## Performance Monitoring

```typescript
class PerformanceMonitor {
  private readonly metrics = new MetricsCollector();
  private readonly alerts = new AlertManager();

  async startMonitoring(): Promise<void> {
    // Monitor video performance
    this.metrics.trackVideo({
      bufferingEvents: true,
      qualityChanges: true,
      frameDrops: true
    });

    // Monitor interaction performance
    this.metrics.trackInteractions({
      swipeLatency: true,
      touchResponse: true,
      animations: true
    });

    // Monitor resource usage
    this.metrics.trackResources({
      memory: true,
      cpu: true,
      network: true
    });

    // Set up alerts
    this.alerts.configure({
      thresholds: {
        bufferingRatio: 0.02,    // Alert if buffering > 2%
        swipeLatency: 200,       // Alert if swipe > 200ms
        memoryUsage: 0.8         // Alert if memory > 80%
      }
    });
  }

  async generateReport(
    timeframe: TimeRange
  ): Promise<PerformanceReport> {
    const data = await this.metrics.collect(timeframe);
    return {
      summary: this.summarizeMetrics(data),
      trends: this.analyzeTrends(data),
      recommendations: this.generateRecommendations(data)
    };
  }
}
```

## Automated Performance Testing Pipeline

```typescript
// github/workflows/performance.yml
name: Performance Tests

on:
  push:
    branches: [main, staging]
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight

jobs:
  performance:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Environment
        run: |
          npm ci
          npm run build
          
      - name: Start Test Server
        run: npm run start:test
        
      - name: Run Video Performance Tests
        run: npm run test:video-performance
        
      - name: Run Load Tests
        run: npm run test:load
        
      - name: Run Network Tests
        run: npm run test:network
        
      - name: Generate Performance Report
        run: npm run generate-performance-report
        
      - name: Upload Results
        uses: actions/upload-artifact@v2
        with:
          name: performance-results
          path: performance-report.json
```

## Performance Testing Best Practices

1. Always test with production-like data volumes
2. Test across multiple device types and browsers
3. Monitor memory leaks during extended sessions
4. Test with realistic network conditions
5. Measure perceived performance metrics
6. Automate regular performance testing
7. Track trends over time
8. Set clear performance budgets

## Performance Budgets

```typescript
const performanceBudgets = {
  // Time to first meaningful paint
  ttfmp: 2000,  // 2 seconds
  
  // Time to interactive
  tti: 3500,    // 3.5 seconds
  
  // Video startup time
  videoStart: 2000,  // 2 seconds
  
  // Bundle sizes
  javascript: 300 * 1024,   // 300KB
  css: 50 * 1024,          // 50KB
  
  // Runtime metrics
  fps: 60,
  memoryHeap: 100 * 1024 * 1024,  // 100MB
  longTasks: 50  // Max 50ms
};
```

This comprehensive performance testing strategy ensures our video application maintains high quality and responsiveness across all usage scenarios.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: docs/testing/strategy.md
================================================
# Testing Strategy

## Overview

This document outlines our comprehensive testing strategy for ReelMeals. As a video-centric application with real-time features, our testing approach must ensure reliable video playback, smooth user interactions, and data consistency across all environments.

## Testing Pyramid

We follow a modified testing pyramid approach that emphasizes both traditional testing layers and video-specific testing requirements:

```typescript
interface TestingStrategy {
  unit: {
    coverage: number;        // Target: 80%
    priority: 'high';
    tooling: ['Jest', 'React Testing Library'];
  };
  integration: {
    coverage: number;        // Target: 70%
    priority: 'high';
    tooling: ['Cypress', 'Firebase Emulators'];
  };
  e2e: {
    coverage: number;        // Target: 50%
    priority: 'medium';
    tooling: ['Playwright'];
  };
  video: {
    coverage: number;        // Target: 90%
    priority: 'critical';
    tooling: ['Video Testing Suite', 'Stream Analyzer'];
  };
}
```

## Unit Testing

Our unit testing approach focuses on isolated component and utility testing:

```typescript
// Example component test
describe('VideoPlayer Component', () => {
  const mockVideo = {
    id: 'test-video',
    url: 'https://example.com/video.mp4',
    title: 'Test Video'
  };

  it('should render video player with correct source', () => {
    render(<VideoPlayer video={mockVideo} />);
    const videoElement = screen.getByTestId('video-player');
    expect(videoElement).toHaveAttribute('src', mockVideo.url);
  });

  it('should handle play/pause interactions', async () => {
    const user = userEvent.setup();
    render(<VideoPlayer video={mockVideo} />);
    
    const playButton = screen.getByRole('button', { name: /play/i });
    await user.click(playButton);
    
    expect(screen.getByTestId('video-player')).toHaveProperty('paused', false);
  });

  it('should update progress bar during playback', () => {
    jest.useFakeTimers();
    render(<VideoPlayer video={mockVideo} />);
    
    // Simulate video progress
    const videoElement = screen.getByTestId('video-player');
    fireEvent.timeUpdate(videoElement, { target: { currentTime: 30 } });
    
    const progressBar = screen.getByRole('progressbar');
    expect(progressBar).toHaveAttribute('aria-valuenow', '30');
  });
});

// Example utility test
describe('VideoProcessor Utility', () => {
  const mockVideoData = new Blob(['mock video data'], { type: 'video/mp4' });

  it('should process video metadata correctly', async () => {
    const metadata = await VideoProcessor.extractMetadata(mockVideoData);
    expect(metadata).toHaveProperty('duration');
    expect(metadata).toHaveProperty('resolution');
  });

  it('should generate video thumbnails', async () => {
    const thumbnails = await VideoProcessor.generateThumbnails(mockVideoData, {
      count: 3,
      interval: 5
    });
    expect(thumbnails).toHaveLength(3);
    thumbnails.forEach(thumbnail => {
      expect(thumbnail).toMatch(/^data:image\/jpeg;base64,/);
    });
  });
});
```

## Integration Testing

We use Cypress for integration testing, with a focus on user flows and Firebase integration:

```typescript
// cypress/integration/video-discovery.spec.ts
describe('Video Discovery Flow', () => {
  beforeEach(() => {
    cy.initializeFirebaseEmulators();
    cy.seedTestData();
  });

  it('should load and play videos in sequence', () => {
    cy.visit('/discover');
    
    // Verify first video loads
    cy.get('[data-testid="video-player"]')
      .should('be.visible')
      .and('have.prop', 'readyState', 4);
    
    // Verify swipe interaction
    cy.get('[data-testid="video-container"]')
      .trigger('mousedown', { position: 'center' })
      .trigger('mousemove', { clientX: -200 })
      .trigger('mouseup');
    
    // Verify next video loads
    cy.get('[data-testid="video-player"]')
      .should('have.attr', 'src')
      .and('not.eq', initialVideoSrc);
  });

  it('should persist user interactions', () => {
    cy.login();
    cy.visit('/discover');
    
    // Save video to collection
    cy.get('[data-testid="save-button"]').click();
    cy.get('[data-testid="collection-modal"]').should('be.visible');
    cy.get('[data-testid="collection-name"]').type('Favorites');
    cy.get('[data-testid="save-to-collection"]').click();
    
    // Verify persistence
    cy.visit('/collections');
    cy.get('[data-testid="collection-card"]')
      .should('contain', 'Favorites')
      .click();
    cy.get('[data-testid="video-thumbnail"]').should('exist');
  });
});
```

## End-to-End Testing

We use Playwright for comprehensive end-to-end testing across browsers:

```typescript
// tests/e2e/video-playback.spec.ts
test.describe('Video Playback Experience', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('should handle video playback across network conditions', async ({ page }) => {
    // Test with different network conditions
    const conditions = [
      { latency: 0, downloadThroughput: 1024 * 1024 }, // 1 mbps
      { latency: 100, downloadThroughput: 512 * 1024 }, // 512 kbps
      { latency: 200, downloadThroughput: 256 * 1024 }  // 256 kbps
    ];

    for (const condition of conditions) {
      await page.route('**/*', async route => {
        await route.continue({
          throttling: condition
        });
      });

      // Verify adaptive playback
      const startTime = await page.evaluate(() => {
        const video = document.querySelector('video');
        return video.currentTime;
      });

      await page.waitForTimeout(5000);

      const endTime = await page.evaluate(() => {
        const video = document.querySelector('video');
        return video.currentTime;
      });

      expect(endTime).toBeGreaterThan(startTime);
    }
  });
});
```

## Video-Specific Testing

We implement specialized tests for video functionality:

```typescript
// tests/video/streaming.test.ts
describe('Video Streaming Capabilities', () => {
  const videoTestSuite = new VideoTestSuite();

  test('should adapt video quality based on network conditions', async () => {
    const testVideo = await videoTestSuite.loadTestVideo('sample-4k.mp4');
    const streamAnalyzer = new StreamAnalyzer(testVideo);
    
    // Test different network conditions
    const results = await streamAnalyzer.analyzeAdaptiveBitrate({
      conditions: [
        { speed: '5mbps', expectQuality: '1080p' },
        { speed: '2mbps', expectQuality: '720p' },
        { speed: '1mbps', expectQuality: '480p' }
      ]
    });
    
    results.forEach(result => {
      expect(result.actualQuality).toBe(result.expectedQuality);
      expect(result.bufferingEvents).toBeLessThan(3);
      expect(result.adaptationTime).toBeLessThan(2000);
    });
  });

  test('should maintain playback during network fluctuations', async () => {
    const networkSimulator = new NetworkSimulator();
    const playbackMonitor = new PlaybackMonitor();
    
    await networkSimulator.startTest({
      initialCondition: 'good',
      fluctuations: [
        { condition: 'poor', duration: 5000 },
        { condition: 'good', duration: 5000 },
        { condition: 'offline', duration: 2000 }
      ]
    });
    
    const results = await playbackMonitor.getResults();
    expect(results.totalStalls).toBeLessThan(2);
    expect(results.recoveryTime).toBeLessThan(3000);
  });
});
```

## Performance Testing

We implement comprehensive performance testing:

```typescript
// tests/performance/video-performance.test.ts
describe('Video Performance Metrics', () => {
  const performanceMonitor = new PerformanceMonitor();

  test('should meet video start time requirements', async () => {
    const results = await performanceMonitor.measureVideoStart({
      samples: 10,
      networkConditions: ['4g', '3g'],
      devices: ['desktop', 'mobile']
    });

    expect(results.averageStartTime).toBeLessThan(2000);
    expect(results.p95StartTime).toBeLessThan(3000);
  });

  test('should maintain smooth playback', async () => {
    const playbackMetrics = await performanceMonitor.measurePlayback({
      duration: 30000,
      metrics: ['fps', 'dropped-frames', 'buffer-health']
    });

    expect(playbackMetrics.averageFps).toBeGreaterThan(25);
    expect(playbackMetrics.droppedFrames).toBeLessThan(30);
    expect(playbackMetrics.bufferHealth).toBeGreaterThan(5000);
  });
});
```

## Firebase Integration Testing

We use Firebase Emulators for testing Firebase integration:

```typescript
// tests/firebase/authentication.test.ts
describe('Firebase Authentication Flow', () => {
  beforeAll(async () => {
    await connectAuthEmulator(auth, 'http://localhost:9099');
    await connectFirestoreEmulator(db, 'localhost', 8080);
  });

  test('should handle user authentication and data persistence', async () => {
    const { user } = await signInWithEmailAndPassword(
      auth,
      'test@example.com',
      'password123'
    );

    // Verify user document creation
    const userDoc = await getDoc(doc(db, 'users', user.uid));
    expect(userDoc.exists()).toBe(true);
    expect(userDoc.data()).toHaveProperty('lastLogin');

    // Verify video interactions
    await addVideoToCollection(user.uid, 'test-video-id');
    const collections = await getUserCollections(user.uid);
    expect(collections).toHaveLength(1);
    expect(collections[0].videos).toContain('test-video-id');
  });
});
```

## Continuous Integration

We integrate tests into our CI pipeline:

```yaml
# .github/workflows/test.yml
name: Test Suite
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
          
      - name: Install Dependencies
        run: npm ci
        
      - name: Start Firebase Emulators
        run: npm run emulators:start &
        
      - name: Run Unit Tests
        run: npm run test:unit
        
      - name: Run Integration Tests
        run: npm run test:integration
        
      - name: Run E2E Tests
        run: npm run test:e2e
        
      - name: Run Video Tests
        run: npm run test:video
        
      - name: Upload Coverage
        uses: codecov/codecov-action@v2
```

## Test Data Management

We maintain consistent test data across environments:

```typescript
// tests/utils/test-data.ts
class TestDataManager {
  private readonly firestoreEmulator: Firestore;
  
  async seedTestData() {
    // Seed users
    await this.seedUsers();
    
    // Seed videos
    await this.seedVideos();
    
    // Seed collections
    await this.seedCollections();
    
    // Seed interactions
    await this.seedInteractions();
  }

  private async seedUsers() {
    const users = generateTestUsers(10);
    await Promise.all(
      users.map(user => 
        this.firestoreEmulator
          .collection('users')
          .doc(user.id)
          .set(user)
      )
    );
  }

  private async seedVideos() {
    const videos = generateTestVideos(20);
    await Promise.all(
      videos.map(video =>
        this.firestoreEmulator
          .collection('videos')
          .doc(video.id)
          .set(video)
      )
    );
  }
}
```

This testing strategy ensures comprehensive coverage of our application's functionality while maintaining a focus on video-specific requirements and performance metrics.

---

*Version: 1.0.0*
*Last Updated: February 3, 2025*

================================================
File: .cursor/rules/state-management-rules.mdc
================================================
---
description: 
globs: src/features/state/**/*
---
rules:
  - "Use Firebase Real-time Database for video progress sync"
  - "Implement offline support using IndexedDB"
  - "Cache video metadata but not video content"

commands:
  generate_types: "npm run codegen:firebase-types"


================================================
File: .cursor/rules/swipe-interaction-rules.mdc
================================================
---
description: 
globs: src/features/swipe/**/*
---
rules:
  - "Use CSS transforms exclusively for animations"
  - "Implement velocity-based gestures using @use-gesture/react"
  - "Handle multi-touch scenarios gracefully"

performance_metrics:
  - "Touch response < 16ms"
  - "Animation frame budget: 16ms"
  
error_handling:
  - "Provide fallback UI for touch-unsupported devices"
  - "Reset gesture state on error"

================================================
File: .cursor/rules/video-playback-rules.mdc
================================================
---
description: 
globs: src/features/video-player/**/*
---

rules:
  - "Use hardware acceleration when available through videojs-contrib-quality-levels"
  - "Implement adaptive bitrate streaming with at least 3 quality levels"
  - "Always preload next video when current video is 70% complete"

examples:
  - "src/features/video-player/examples/adaptive-streaming.tsx"
  - "src/features/video-player/examples/preload-implementation.tsx"

commands:
  test: "npm run test:video"
  benchmark: "npm run benchmark:video-playback"

